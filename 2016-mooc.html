<!-- BEGIN HEADER -->
<!DOCTYPE html>
<html>
    <head>
        <title>Web-palvelinohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/chartist.min.css"/>
        <link rel="stylesheet" href="css/wepa.css"/>

        <link rel="stylesheet" href="css/wepa-mooc.css"/>

    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <a href="http://www.mooc.fi" class="hidden-in-hy">&#171; mooc.fi</a>

            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="index.html">Yleistä</a>
                    </li>
                    <li>
                        <a href="osa1.html">Osa 1</a>
                    </li>
                    <li>
                        <a href="osa2.html">Osa 2</a>
                    </li>
<!--
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
-->
                </ul>

		<div style="direction: rtl;">
		  <button id="logout" class="btn btn-warning">Kirjaudu ulos</button>
		</div>
            </nav>

        </header>
        <!-- // END NAV -->
        <article>


          <div class="modal fade" id="tmcAuthModal" data-backdrop="static" data-keyboard="false"  tabindex="-1" role="dialog" aria-labelledby="tmcAuthModalLabel" aria-hidden="true">
            <div class="modal-dialog">
              <form class="form-inline"  id="TmcLoginForm" role="form">
		<div class="modal-content">
                  <div class="modal-header">
                    <h4 class="modal-title" id="tmcAuthModalLabel">Kirjoita TMC-tunnuksesi</h4>
                  </div>
                  <div class="modal-body">
                    <p>Pyydämme sinua kirjautumaan TMC-tunnuksillasi materiaaliin. Kirjautumistietoja käytetään oppimateriaalin käytön tutkimukseen.</p>
                    <div id="tmc-account-wrong-alert" class="hidden alert alert-danger">Tarkista TMC-tunnuksesi</div>
                    <div class="form-group">
                      <label class="sr-only" for="exampleInputPassword2">TMC-tunnus</label>
                      <input type="text" name="tmcAccountName" class="form-control" id="inputTmcAccount" placeholder="TMC-tunnus">
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" id="tmcAccountNOACCOUNT" class="btn btn-default" data-dismiss="modal">En halua tai en tiedä TMC-tunnustani</button>
                    <button type="submit" name="tmcLoginButton" id="tmcAccountOK" class="btn btn-primary">OK</button>
                  </div>
		</div><!-- /.modal-content -->
              </form>
            </div><!-- /.modal-dialog -->
          </div><!-- /.modal -->

	  <!-- END HEADER -->
	  

          <!-- BEGIN INDEX -->
          <section id="intro" class="no-toc weeklimit" data-week-id="0">

            <header>
	      
              <div class="intro-header-img"></div>
	      
              <h1>Web-palvelinohjelmointi</h1>
	      
              <p>Voinko oppia tekemään Facebookin, Flickrin tai Twitterin?</p>
	      
              <a class="call-to-action" href="#start" role="button">No todellakin!</a>
	      
            </header>
	    
            <h1 id="start">Sisältö, aikataulu ja arvostelu</h1>
	    
            <p>Kurssilla tutustutaan nykyaikaisten, skaalautuvien ja virheenkestävien web-sovellusten toteuttamiseen, testaamiseen ja julkaisemiseen. Kurssilla keskitytään palvelinpuolen toiminnallisuuden toteuttamiseen. Selainpuolen toiminnallisuudella on kurssilla vain pieni paino. Kurssin opetuskieli on suomi ja ohjelmointikieli Java.</p>
	    
          <p>Aiempia kurssin oppimateriaaleja: <a href="s2014-wepa.html">syksy 2014</a>, <a href="s2015-wepa.html">syksy 2015</a> sekä <a href="s2015-wepa-mooc.html">lyhyeksi jäänyt MOOC-kurssi</a>. Edessäsi on kesän 2016 palvelinohjelmoinnin MOOCia varten toteutettu kurssimateriaali.</p>
	    
            <p><a class="jump" href="#teemat" role="button">Teemat ja oppimistavoitteet &raquo;</a></p>
	    
            <h2>Opettajille ja opiskelijoille</h2>
	    
            <p>Kurssi vastaa <a href="http://www.cs.helsinki.fi/home/" target="_blank">Helsingin yliopiston tietojenkäsittelytieteen laitoksen</a> kurssia <a href="http://www.cs.helsinki.fi/en/courses/582353" target="_blank">Web-palvelinohjelmointi</a> (5 opintopistettä). Kurssia ja sen materiaalia saa käyttää ja muokata vapaasti, kunhan noudattaa materiaalin alalaidassa olevaa <a href="#license">lisenssiä</a>.</p>
	    
            <p>Saat opettajana käyttää kurssia vapaasti omassa oppilaitoksessasi, kunhan et pyydä kurssista maksua opiskelijoilta.</p>
	    
            <p>Kurssin suorittaminen tapahtuu Helsingin yliopiston Avoimen yliopiston kautta (kurssi alkaa 11.7.2016). Jos olet opiskelijana jossain muualla kuin Helsingin yliopistolla ja haluaisit suorittaa kurssin siten, että saat suoritusmerkinnän tai opintopisteet omassa oppilaitoksessasi, etsi omasta oppilaitoksestasi opettaja tai opinto-ohjaaja, joka on valmis valvomaan kokeen ja hyväksymään kurssisuorituksen.</p>

	    <h2>Arvostelu</h2>
	    
            <p>Kurssin arvostelu (Helsingin yliopiston Avoin yliopisto) perustuu harjoitustehtäviin, harjoitustyöhön sekä verkkotenttiin. Kurssin pisteytys on seuraava:</p>
	    
	    <ul>
	      <li>Viikoittaisten harjoitustehtävien tekemisestä voi saada yhteensä 700 pistettä. Kurssilla on seitsemän osiota. Osion tehtävistä saa 100 pistettä kun tekee kaikki tehtävät, 50 pistettä jos tekee puolet tehtävistä jne. </li>
	      <li>Harjoitustyöstä voi saada 300 pistettä. </li>
	      <li>Verkkotentistä voi saada 200 pistettä.</li>
	    </ul>
	    
	    <p>Kurssista voi saada yhteensä 1200 pistettä. Kurssin arvosanarajat ovat seuraavat:</p>
	    
	    <ul>
	      <li>700 -> 1</li>
	      <li>800 -> 2</li>
	      <li>900 -> 3</li>
	      <li>1000 -> 4</li>
	      <li>1100 -> 5</li>
	    </ul>
	    
	    <p>Kurssille voi osallistua myös fiilispohjalta. Tällöin suorituksesta voi saada diplomin, missä näkyy tehtyjen tehtävien määrä.</p>
	    
            <h1>Esitietovaatimukset ja kurssin suorittaminen</h1>
	    
            <p>Kurssilla oletetaan Java-ohjelmointikielen tuntemus kurssien ohjelmoinnin perusteet ja ohjelmoinnin jatkokurssi laajuudessa (vastaa <a href="http://mooc.fi/" target="_blank">mooc.fi</a>-osoitteessa olevaa kurssia Ohjelmoinnin MOOC. Tämän lisäksi oletetaan, että osallistuja tuntee Helsingin yliopistolla järjestettävien kurssien <a href="http://tietokantojen-perusteet.github.io/" target="_blank">Tietokantojen perusteet</a> ja <a href="https://github.com/mluukkai/OTM2015/wiki/Ohjelmistotekniikan-menetelmat" target="_blank">Ohjelmistotekniikan menetelmät</a> sisällöt oleellisilta osin -- tai, että osaajalla on muuta kautta tarvittava osaaminen. Myös kurssin <a href="http://web-selainohjelmointi.github.io" target="_blank">Web-selainohjelmointi</a> tuntemuksesta on hyötyä.</p>
	    
	    <p>Omatoiminen tiedon hakeminen on erittäin tärkeää tällä kurssilla menestymiseen.</p>
	    
	    
	    <h2>Tehtävien tekeminen ja palauttaminen</h2>
	    
	    
	    <p>Kurssin tehtävien tekemisessä hyödynnetään Helsingin yliopiston tietojenkäsittelytieteen laitoksellä kehitettyä <a href="http://testmycode.github.io/" target="_blank">Test My Code</a>-palvelua, joka mm. tarjoaa ohjelmointiympäristöön liitettävän TMC-liitännäisen. Kurssitehtävät noudetaan paikalliselle koneelle TMC-liitännäisen avulla. TMC mahdollistaa myös tehtävien suoraviivaisen palauttamisen tehtäväpalvelimelle. Osa kurssin tehtävistä tarkastetaan automaattisesti TMC-palvelun avulla -- muiden tehtävien toiminta tulee taas tarkastaa itse erilaisten tukimateriaalien kuten kuvien avulla.</p>
	    
	    <p>Kurssilla käytettävä TMC-palvelin löytyy osoitteessa <a href="http://tmc.mooc.fi/mooc" target="_blank">http://tmc.mooc.fi/mooc</a>, kurssin nimenä on <code>2016-wepa</code>. Alkutoimet kurssilla käytettävien työvälineiden asentamiseen löytyy osoitteesta <a href="http://mooc.fi/courses/general/ohjelmointi/" target="_blank">http://mooc.fi/courses/general/ohjelmointi/</a>.</p>
	    
	    
            <h2>Kurssin tukimuodot</h2>
	    
	    <p>Kurssilla käytetään <code>#mooc.fi</code> IRC-kanavaa, josta löytyy muita kurssilaisia. Muiden auttaminen kanavalla on vapaaehtoista, mutta luonnollisesti suositeltavaa. Auttamisesta hyötyy apua tarvitsevan lisäksi myös auttaja. Helsingin yliopiston Avoimen yliopiston opiskelijat voivat keskustella myös kurssin <a href="https://moodle.helsinki.fi/mod/forum/view.php?id=922037" target="_blank">Moodle-foorumilla</a>.</p>
	    
	    <p>Ohjeet IRC:n käyttöön löytyvät <a href="http://mooc.fi/courses/general/ohjelmointi/tukikanavat/irc/ohjeet/" target="_blank">tämän linkin takaa</a>.</p>
	    
	    
            <h1 id="teemat">Teemat ja oppimistavoitteet</h1>

	    <p>Kurssin teemat ja oppimistavoitteet täydentyvät kurssin edetessä. Alustava julkaisuaikataulu: 11.7.2016 (osa1), 18.7.2016 (osa2), 25.7.2016 (osa3), 1.8.2016 (osa4), 8.8.2016 (osa5), 15.8.2016 (osa6), 22.8.2016 (osa7).</p>

	    <p>
	    
	    <table class="table">
	      <thead>
		<tr>
		  <th class="col-md-1">Osa</th>
		  <th class="col-md-4">Teemat</th>
		  <th class="col-md-12">Oppimistavoitteet</th>
		</tr>
	      </thead>
	      <tbody>
		<tr>
		  <td>-</td>
		  <td>Esitiedot</td>
		  <td>Olio-ohjelmointi ja ohjelmointiympäristön käyttö (Ohjelmoinnin MOOC), Yksikkötestaus (Ohjelmistotekniikan menetelmät), Versionhallinta (Ohjelmistotekniikan menetelmät), Relaatiotietokantojen toiminta (Tietokantojen perusteet)</td>
		</tr>
		<tr>
		  <td>1</td>
		  <td>Johdanto web-sovellusten toimintaan. Yhtä tietokantataulua käyttävä web-sovellus.</td>
		  <td>Osaa toteuttaa yhtä tietokantataulua käyttävän web-sovelluksen.</td>
		</tr>
		<tr>
		  <td>2</td>
		  <td>Internetin perusosat. Kerrosarkkitehtuuri ja MVC-malli. Pyynnön kulku web-sovelluksessa. Tietokannat ja tietokanta-abstraktiot. </td>
		  <td>Ymmärtää asiakas-palvelin -mallin. Tietää ensisijaiset kerrosarkkitehtuurin ja MVC-mallin edut. Ymmärtää miten käyttäjän tekemään pyyntöön muodostuu vastaus palvelimella. Osaa luoda web-sovelluksen, joka käyttää useampaa tietokantataulua. Ymmärtää tietokantatransaktioiden käytön ja osaa käyttää niitä web-sovelluksessa.</td>
		</tr>
		<tr>
		  <td>3</td>
		  <td>HTTP-protokolla ja käyttäjän tilan ylläpito. Konfiguraatioprofiilit. Web-sovellusten testaaminen.</td>
		  <td>Ymmärtää HTTP-protokollan hyödyt ja rajoitteet. Ymmärtää mitä evästeet ovat, miten ne toimivat, sekä tietää niihin liittyvät uhkat ja lakitekniset rajoitteet. Osaa luoda kirjautuneen käyttäjän muistavan web-sovelluksen. Osaa kirjoittaa automaattisia yksikkötestejä web-sovellukselle. Ymmärtää paikallisen kehitys- ja testausympäristön hyödyt.</td>
		</tr>
		<tr>
		  <td>4</td>
		  <td>Web-sovelluskehitykseen liittyvä ohjelmistokehitysprosessi. DevOps -kulttuuri. Tietokantamigraatiot. REST-arkkitehtuurimalli. </td>
		  <td>Ymmärtää tarpeen web-sovellusten kehitysprosessin automatisoinnille sekä web-sovellusten jatkuvalle inkrementaaliselle kehitykselle. Ymmärtää versionhallintapalvelun (esim. Github), sovelluksen testejä suorittavan integraatiopalvelun (esim. Travis CI) sekä testi- ja tuotantoympäristön (esim. Heroku) yhteistyön. Ymmärtää sidosryhmien (stakeholder) välisen kommunikaation oleellisuuden sovelluskehityksessä. Hyödyntää valmiita työvälineitä tietokantaskeeman päivittämiseen ohjelmistokehityksen yhteydessä. Ymmärtää REST-arkkitehtuurimallin perusperiaatteet. </td>
		</tr>
		<tr>
		  <td>5</td>
		  <td>Javascript-pohjaisten selainohjelmistojen ja palvelinohjelmistojen yhteistyö. Web-sovellusten tietoturva.</td>
		  <td>Osaa tehdä selainohjelmistosta Javascript-pyynnön palvelimelle. Päivittää näkymän Javascript-pyynnön vastauksen perusteella. Tietää web-sovellusten tyypillisimmät haavoittuvuudet sekä niihin vaikuttavat tekijät (OWASP). Välttää tyypillisimmät haavoittuvuudet omassa ohjelmistossaan. Osaa etsiä haavoittuvuuksia muiden ohjelmistoista sekä ehdottaa niihin korjauksia.</td>
		</tr>
		<tr>
		  <td>6</td>
		  <td>Web-sovellusten skaalaaminen isoille käyttäjäjoukoille. Asynkroniset metodikutsut. Palveluperustaiset arkkitehtuurit ja mikroarkkitehtuurit.</td>
		  <td>Ymmärtää sovelluksen vasteajan ja käyttäjäkokemuksen yhteyden. Ymmärtää web-sovellusten pullonkaulat ja osaa ehdottaa tapoja pullonkaulojen kiertämiseen. Ymmärtää vertikaaliseen ja horisontaaliseen skaalautumiseen liittyvät hyödyt ja haasteet.  Ymmärtää palveluperustaisten arkkitehtuurien ja mikroarkkitehtuurien perusperiaatteet. Osaa tehdä web-sovelluksen, joka käyttää ja kerää tietoa useammasta erillisestä web-sovelluksesta.</td>
		</tr>
		<tr>
		  <td>7</td>
		  <td>Reaktiivinen ohjelmointi. Kertaus.</td>
		  <td>Ymmärtää reaktiivisen ohjelmoinnin perusteet ja osaa tehdä yksinkertaisen palvelinohjelmiston reaktiivisella ohjelmointiparadigmalla. </td>
		</tr>	      	      
	      </tbody>
	    </table>

<!--
            <ul id="week-toc">
              <li><a href="#osa1">Osa 1</a> Johdanto web-sovellusten tekemiseen.</li>
              <li><a href="#osa2">Osa 2</a> HTTP-protokolla, sessiot, relaatiotietokannan käyttö.</li>
	    </ul>
	    
	    <p>Teemalistausta täydennetään kurssin edetessä.</p>
-->
	    
	    
          </section>
          <!-- END INDEX -->
	  
	  <!-- BEGIN CONTENT -->
	  <section class="no-toc weeklimit" data-week-id="0">
            <h1>Sisällysluettelo</h1>
	    
            <ul class="nav" id="material-toc"></ul>
	    
            <h1>Tehtävät</h1>
	    
            <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>
	    
	  </section>
	  <!-- END CONTENT -->

          <!-- BEGIN OSA1 -->
          <section class="weeklimit" data-week-id="1">
	    
            <header>
              <h1 id="osa1">Osa 1</h1>
            </header>
	    
            <h1>Web-sovellusten alkeet</h1>
	    
            <p>Web-sovellukset koostuvat selain- ja palvelinpuolesta. Käyttäjän koneella toimii selainohjelmisto (esim. <a href="http://chrome.google.com" target="_blank">Google Chrome</a>), jonka kautta käyttäjä tekee pyyntöjä verkossa sijaitsevalle palvelimelle. Kun palvelin vastaanottaa pyynnön, se käsittelee pyynnön ja rakentaa vastauksen. Vastaus voi sisältää esimerkiksi web-sivun HTML-koodia tai jossain muussa muodossa olevaa tietoa.</p>
	    
            <div class="image">
              <img src="img/pyynto.png"/>
              <div>Web-sovellusten käyttäminen: (1) käyttäjä klikkaa linkkiä, (2) selain tekee pyynnön palvelimelle, (3) palvelin käsittelee pyynnön ja rakentaa vastauksen, (4) selaimen tekemään pyyntöön palautetaan vastaus, (5) vastauksen näyttäminen käyttäjälle -- ei tässä kuvassa.</div>
            </div>
	    
            <p>Selainohjelmointiin ja käyttöliittymäpuoleen keskityttäessä painotetaan rakenteen, ulkoasun ja toiminnallisuuden erottamista toisistaan. Karkeasti voidaan sanoa, että selaimessa näkyvän sivun rakenne määritellään <a href="http://en.wikipedia.org/wiki/HTML" target="_blank">HTML</a>-tiedostoilla, ulkoasu <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>-tiedostoilla ja toiminnallisuus <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>-tiedostoilla.</p>
	    
            <p>Palvelinpuolen toiminnallisuutta toteutettaessa keskitytään tyypillisesti selainohjelmiston tarvitsevan "APIn" suunnitteluun ja toteutukseen, sivujen muodostamiseen selainohjelmistoa varten, datan tallentamiseen ja käsittelyyn, sekä sellaisten laskentaoperaatioiden toteuttamiseen, joita selainohjelmistossa ei kannata tai voida tehdä.</p>
	    
	    
	    <h2>Ensimmäinen palvelinohjelmisto</h2>
	    
	    <p>Käytämme kurssilla <a href="https://spring.io/" target="_blank">Spring</a> -sovellusperheen <a href="http://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a> -projektia web-sovellusten tekemiseen. Merkittävä osa web-sovellusten rakentamisesta perustuu valmiiden kirjastometodien käyttöön. Niiden avulla määritellään (1) mihin osoitteeseen tulevat pyynnöt käsitellään ja (2) mitä pyynnölle tulee tehdä.</p>
	    
	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Maven</h1>
	      
	      <p>Käytämme tällä kurssilla <a href="https://maven.apache.org/" target="_blank">Maven</a>ia valmiiden kirjastojen noutamiseen sekä projektien hallintaan. Tämän takia projektimme on luotu Maven-projekteina -- uuden Maven-projektin luominen onnistuu NetBeansissa valitsemalla File -&gt; New Project -&gt; Maven -&gt; Java Application.</p>
	      
	      <p>Maven-projektin riippuvuudet määritellään projektiin liittyvässä (Project Files) <code>pom.xml</code>-tiedostossa olevassa <code>dependencies</code>-osiossa.</p>
	      
	    </aside>
	    
	    <p>Spring -sovelluskehystä käyttävien web-sovellusten kehityksessä käytettävät osat saa käyttöön lisäämällä projektiin riippuvuuden Spring Boot -projektiin (<code>spring-boot-starter-parent</code>) sekä web-projektiin (<code>spring-boot-starter-web</code>).</p>

<pre class="sh_xml">
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.4.0.RC1&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>

            <aside class="info">

	      <br/>
	      
	      <h1>Release Candidate</h1>

	      <p>Käytämme toistaiseksi Spring Boot -projektin version 1.4. esiversiota. Tehtäväpohjiin on valmiiksi määritelty sijainti, mistä esiversio löytyy. Omia kokeiluja varten tulee projektin <code>pom.xml</code>-tiedostoon lisätä määrittely esiversion löytämiseksi:</p>

<pre class="sh_xml">
&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-milestones&lt;/id&gt;
        &lt;name&gt;spring-milestones&lt;/name&gt;
        &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt;
        &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/releases&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</pre>

	    </aside>

	    <p>Kun riippuvuudet on lisätty projektiin ja projektista pääsee käsiksi Spring-sovelluskehyksen metodeihin ja luokkiin, voimme luoda ensimmäisen palvelinohjelmistomme.</p>

<pre class="sh_java">
package heimaailma;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@SpringBootApplication
@Controller
public class HeiMaailmaController {

    @RequestMapping("*")
    @ResponseBody
    public String home() {
        return "Hei Maailma!";
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HeiMaailmaController.class, args);
    }
}
</pre>

	    <p>Yllä olevassa esimerkissä luodaan pyyntöjä vastaanottava luokka. Pyyntöjä vastaanottavat luokat merkitään <code>@Controller</code>-annotaatiolla. Tämän perusteella Spring-sovelluskehys tietää, että luokan metodit saattavat käsitellä selaimesta tehtyjä pyyntöjä.</p>

	    <p>Luokalle on määritelty lisäksi metodi <code>home</code>, jolla on kaksi annotaatiota: <code>@RequestMapping</code> ja <code>@ResponseBody</code>. Annotaation <code>@RequestMapping</code> avulla määritellään kuunneltava osoite -- tässä kaikki <code>"*"</code>. Annotaatio <code>@ResponseBody</code> kertoo sovelluskehykselle, että metodin vastaus tulee näyttää vastauksena sellaisenaan.</p>

	    <p>Eriytämme pyyntöjä vastaanottavat luokat ja sovelluksen käynnistämiseen käytettävän luokan jatkossa toisistaan.</p>

<pre class="sh_java">
package heimaailma;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HeiMaailmaApplication {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HeiMaailmaApplication.class, args);
    }
}
</pre>

<pre class="sh_java">
package heimaailma;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HeiMaailmaController {

    @RequestMapping("*")
    @ResponseBody
    public String home() {
        return "Hei Maailma!";
    }
}
</pre>


	    <aside class="info">
	      <br/>
	      <h1>Tehtävien tekeminen</h1>
	      
              <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi.</p>
	      
	      <p>Oletamme, että olet seurannut kurssin työvälineiden hakemiseen liittyviä ohjeita osoitteessa <a href="http://mooc.fi/courses/general/ohjelmointi/" target="_blank">http://mooc.fi/courses/general/ohjelmointi/</a> ja valinnut kurssiksi <code>2016-wepa</code>.</p>
	      
	      <p>Saat tehtävän auki klikkaamalla sen nimeä.</p>
	      
	    </aside>
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-helloweb-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                      Hello World!
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloweb" class="collapse">
		  
                  <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>
		  
                  <p>Toteuta tehtäväpohjan pakkauksessa <code>wad.helloworld</code> olevaan <code>HelloWorldController</code> luokkaan toiminnallisuus, joka kuuntelee kaikkia pyyntöjä. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>
		  
                  <p><img class="browser-img" src="img/2016-mooc/ex1.png"/></p>
		  
                  <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>HelloWorldApplication</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> ja näet selaimessasi tekstin "Hello World!".</p>
		  
                  <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                </div>
              </div>
	    </div>
	    
	    
	    <aside class="info">
	      <br/>
	      <h1>Apua! Palvelimeni ei suostu sammumaan!</h1>
	      
	      <p>Palvelimen sammuttaminen tapahtuu NetBeansissa punaista neliötä klikkaamalla, joka sammuttaa suoritettavan ohjelman. Joissakin käyttöjärjestelmissä tämä on kuitenkin bugista, jolloin palvelin tulee sammuttaa komentoriviltä.</p>
	      
	      <p>Saat portissa 8080 käynnissä olevan prosessin tunnuksen tietoon terminaalissa komennolla <code>lsof -i :8080</code>. Etsi komennon palauttamasta tulosteesta prosessin tunnus, jonka jälkeen voit sammuttaa prosessin komennolla <code>kill -9 prosessin-tunnus</code>.</p>
	      
	      <p>Esimerkiksi:</p>
		  
<pre>
> lsof -i :8080
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
>
</pre>

	      <p>Yllä prosessin tunnus (PID) on 9916. Tämän jälkeen prosessi sammutetaan komennolla <code>kill -9 9916</code>.</p>

<pre>
> lsof -i :8080
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
> kill -9 9916
</pre>

	    </aside>


	    <h2>Palvelinohjelmiston polut</h2>

	    <p>Opimme aiemmin, että voimme kuunnella kaikkia palvelinohjelmistoon tulevia pyyntöjä asettamalla <code>@RequestMapping</code>-annotaation parametriksi <code>"*"</code>. Käytännössä tämän parametrin avulla määritellään <em>polku</em>, johon palvelimelle tulevat pyynnöt voidaan ohjata. Tähdellä määritellään, että kaikki pyynnöt päätyvät samalle polulle. Muiden polkujen määrittely on luonnollisesti myös mahdollista.</p>
	    
	    <p>Antamalla poluksi merkkijonon <code>"/salaisuus"</code>, kaikki web-palvelimen osoitteeseen <code>/salaisuus</code> tehtävät pyynnöt ohjautuvat kyseiseen polkuun liitettyyn toiminnallisuuteen. Allaolevassa esimerkissä määritellään polku <code>/salaisuus</code> ja kerrotaan, että polkuun tehtävät pyynnöt palauttavat merkkijonon <code>"Kryptos"</code>.</p>
	    
<pre class="sh_java">
    @RequestMapping("/salaisuus")
    @ResponseBody
    public String home() {
        return "Kryptos";
    }
</pre>

	    <p>Yhteen ohjelmaan voi myös määritellä useampia polkuja sekä niihin liittyviä toiminnallisuuksia. Jokainen polku käsitellään omassa metodissaan. Alla olevassa esimerkissä pyyntöjä vastaanottavaan luokkaan on määritelty kolme erillistä polkua, joista jokainen palauttaa käyttäjälle merkkijonon.</p>

<pre class="sh_java">
package polut;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PolkuController {

    @RequestMapping("/path")
    @ResponseBody
    public String path() {
        return "Polku (path)";
    }

    @RequestMapping("/route")
    @ResponseBody
    public String route() {
        return "Polku (route)";
    }

    @RequestMapping("/trail")
    @ResponseBody
    public String trail() {
        return "Polku (trail)";
    }
}
</pre>
	    <p></p>

	    <div class="tehtavat">
	      
	      <div class="tehtava" id="t-hellopaths">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopaths">
                      Hello Paths
                    </a>
                  </h1>
                </header>
                <div id="t-hellopaths" class="collapse">
		  
                  <p>Toteuta pakkauksessa <code>wad.hellopaths</code> olevaan luokkaan <code>HelloPathsController</code> seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/hello</code> palauttaa käyttäjälle merkkijonon "Hello"</li>
		    <li>Pyyntö polkuun <code>/paths</code> palauttaa käyttäjälle merkkijonon "Paths"</li>
		  </ul>
		  
		  <p>Alla olevassa kuvassa on esimerkki tilanteesta, missä selaimella on tehty pyyntö polkuun <code>/hello</code></p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex2.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    <h2>Pyynnön parametrit</h2>
	    
	    <p>Pyynnöissä voi lähettää palvelimelle tietoa. Tutustutaan ensin tapaan, missä pyynnön parametrit lisätään osaksi haettavaa osoitetta. Esimerkiksi pyynnössä <code>http://localhost:8080/salaisuus?onko=nauris</code> on parametri nimeltä <code>onko</code>, jonka arvoksi on määritelty arvo <code>nauris</code>.</p>
	    
	    <p>Parametrien lisääminen pyyntöön tapahtuu lisäämällä osoitteen perään kysymysmerkki, jota seuraa parametrin nimi, yhtäsuuruusmerkki ja parametrille annettava arvo. Pyynnössä tuleviin parametreihin pääsee käsiksi <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html" target="_blank">@RequestParam</a></code>-annotaation avulla.</p>

	    <p>Allaolevassa esimerkissä on luotu palvelinohjelma, jonka tehtävänä on tervehtiä kaikkia pyynnön tekijöitä. Ohjelma käsittelee polkuun <code>/hei</code> tulevia pyyntöjä ja palauttaa niihin vastauksena tervehdyksen. Tervehdykseen liitetään pyynnössä tulevan <code>nimi</code>-nimisen parametrin arvo.</p>

<pre class="sh_java">
package parametrit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TervehtijaController {

    @RequestMapping("/hei")
    @ResponseBody
    public String tervehdi(@RequestParam String nimi) {
        return "Hei " + nimi + ", mitä kuuluu?";
    }
}
</pre>

	    <p>Nyt esimerkiksi osoitteeseen <code>http://localhost:8080/hei?nimi=Ada</code> tehtävä pyyntö saa vastaukseksi merkkijonon <code>Hei Ada, mitä kuuluu?</code>.</p>


	    <p>Jos parametreja on useampia, erotellaan ne toisistaan &amp;-merkillä. Seuraavassa esimerkissä pyynnössä on kolme parametria, <code>eka</code>, <code>toka</code> ja <code>kolmas</code>, joiden arvot ovat <code>1</code>, <code>2</code> ja <code>3</code> vastaavasti.</p>
	    
<pre>
http://localhost:8080/salaisuus?eka=1&amp;toka=2&amp;kolmas=3
</pre>

	    <p>Kaikki pyynnössä olevat parametrit saa pyyntöä käsittelevät metodin käyttöön samalla <code>@RequestParam</code>-annotaatiolla. Allaolevassa esimerkissä kaikki pyynnön parametrit asetetaan <code>Map</code>-tietorakenteeseen, jonka jälkeen kaikki pyynnön arvojen avaimet palautetaan kysyjälle.</p>

<pre class="sh_java">
package parametrit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PyyntoParametrienNimetController {

    @RequestMapping("/nimet")
    @ResponseBody
    public String nimet(@RequestParam Map&lt;String, String&gt; parametrit) {
        return parametrit.keySet().toString();
    }
}
</pre>


	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellorequestparams">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellorequestparams">
                      Hello Request Params
                    </a>
                  </h1>
                </header>
                <div id="t-hellorequestparams" class="collapse">
		  
                  <p>Toteuta pakkauksessa <code>wad.hellorequestparams</code> olevaan luokkaan <code>HelloRequestParamsController</code> seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/hello</code> palauttaa käyttäjälle merkkijonon "Hello ", johon on liitetty <code>param</code>-nimisen parametrin sisältämä arvo.</li>
		    <li>Pyyntö polkuun <code>/params</code> palauttaa käyttäjälle kaikkien pyynnön mukana tulevien parametrien nimet ja arvot.</li>
		  </ul>
		  
		  <p>Alla olevassa kuvassa on esimerkki tilanteesta, missä selaimella on tehty pyyntö polkuun <code>/params?hello=world&amp;it=works</code></p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex3.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-calculator">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-calculator">
                      Calculator
                    </a>
                  </h1>
                </header>
                <div id="t-calculator" class="collapse">
		  
		  <p>Toteuta tässä tehtävässä pakkauksessa <code>wad.calculator</code> sijaitsevaan <code>CalculatorController</code>-luokkaan seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/add</code> laskee parametrien <code>first</code> ja <code>second</code> arvot yhteen ja palauttaa vastauksen käyttäjälle. Huomaa että arvot ovat numeroita, ja ne tulee myös käsitellä numeroina.</li>
		    
		    <li>Pyyntö polkuun <code>/multiply</code> kertoo parametrien <code>first</code> ja <code>second</code> arvot ja palauttaa vastauksen käyttäjälle.</li>
		    
		    <li>Pyyntö polkuun <code>/sum</code> laskee <em>kaikkien</em> parametrien arvot yhteen ja palauttaa vastauksen käyttäjälle.</li>
		  </ul>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun pyyntö tehdään <code>/sum</code>-polkuun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex4.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
            <h2>Näkymät ja data</h2>
	    

            <p>Tähän asti luomamme sovellukset ovat vastaanottaneet tiettyyn polkuun tulevan pyynnön ja palauttaneet käyttäjälle merkkijonomuodossa olevaa tietoa. Tämä ei kuitenkaan ole ainoa palvelinohjelmistojen toimintatyyppi, vaan palvelin voi myös luoda käyttäjälle näkymän, jonka selain lopulta näyttää käyttäjälle. Näkymät luodaan tyypillisesti HTML-kielellä siten, että HTML-kielen sekaan on upotettu komentoja, joiden perusteella näkymään lisätään palvelimen tuottamaa tietoa.</p>
	    
            <p>Tällä kurssilla käyttämämme apuväline näkymän luomiseen on <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>, joka tarjoaa välineitä datan lisäämiseen HTML-sivuille. Käytännössä näkymiä luodessa luodaan ensin HTML-sivut, jonka jälkeen sivuille lisätään komentoja Thymeleafin käsiteltäväksi.</p>
	    
            <p>Thymeleaf-sivut ("templatet") sijaitsevat tällä kurssilla projektin kansiossa <code>src/main/resources/templates</code> tai sen alla olevissa kansioissa. NetBeansissa kansio löytyy kun klikataan "Other Sources"-kansiota.</p>

	    <aside class="info">
	      <br/>
	      
	      <h1>Thymeleafin käyttöönotto</h1>
	      
              <p>Thymeleafin käyttöönotto vaatii <code>pom.xml</code>-tiedostossa olevien riippuvuuksien muokkaamista. Web-sovellusten perustoiminnallisuus saatiin käyttöön lisäämällä <code>org.springframework.boot</code>-ryhmän komponentti <code>spring-boot-starter-web</code> pom.xml-tiedoston dependencies-osioon. Kun vaihdamme riippuvuuden muotoon <code>spring-boot-starter-thymeleaf</code>, pääsemme käyttämään Thymeleafia.</p>
	      
              <pre class="sh_xml">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>

	      <p>Jos edellämainittu riippuvuus ei ole aiemmin ladattuna koneelle, tulee se myös hakea. Tämä onnistuu joko kirjoittamalla komentorivillä projektin juuressa komento <code>mvn dependency:resolve</code> tai valitsemalle NetBeansissa projektiin liittyvä kansio <em>Dependencies</em> oikealla hiirennapilla ja painamalla <em>Download Declared Dependencies</em>.</p>
	      
	      <p>Thymeleaf vaatii myös, että jokaisen HTML-sivun <code>html</code>-elementin määrittelyssä tulee olla seuraavat määrittelyt.</p>

              <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;</pre>
	    </aside>

	    
	    <p>Allaolevassa esimerkissä luodaan juuripolkua <code>/</code> kuunteleva sovellus. Kun sovellukseen tehdään pyyntö, palautetaan HTML-sivu, jonka Thymeleaf käsittelee. Thymeleaf päättelee palautettavan sivun metodin palauttaman merkkijonon perusteella. Alla metodi palauttaa merkkijonon <code>"index"</code>, jolloin Thymeleaf etsii kansiosta <code>src/main/resources/templates/</code> sivua <code>index.html</code>. Kun sivu löytyy, Thymeleaf käsittelee sen ja palauttaa sen käyttäjälle. Palaamme tarkemmin tähän käsittelyyn myöhemmin.</p>


<pre class="sh_java">
package thymeleaf;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ThymeleafController {

    @RequestMapping("/")
    public String home() {
        return "index";
    }
}
</pre>

	    <p>Huomaa, että pyyntöjä käsittelevällä metodilla ei enää ole annotaatiota <code>@ResponseBody</code>. Emme siis enää halua, että metodin palauttama arvo näytetään suoraan käyttäjälle, vaan haluamme, että käyttäjälle näytetään merkkijonon ilmaisema näkymä. Näkymä luodaan Thymeleafin avulla.</p>


	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellothymeleaf">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellothymeleaf">
                      Hello Thymeleaf
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellothymeleaf" class="collapse">
		  
		  <p>Toteuta tässä tehtävässä pakkauksessa <code>wad.hellothymeleaf</code> sijaitsevaan <code>HelloThymeleafController</code>-luokkaan seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö juuripolkuun <code>/</code> palauttaa käyttäjälle Thymeleafin avulla kansiossa <code>src/main/resources/templates/</code> olevan <code>index.html</code>-tiedoston.</li>
		    
		    <li>Pyyntö polkuun <code>/video</code> palauttaa käyttäjälle Thymeleafin avulla kansiossa <code>src/main/resources/templates/</code> olevan <code>video.html</code>-tiedoston.</li>
		    
		  </ul>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun selaimella on tehty pyyntö sovelluksen juuripolkuun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex5.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>


	    <aside class="info">
	      <br/>
	      <h1>HTML</h1>

	      <p>Jos mietit mistä ihmeestä tuossa HTML-lyhenteessä on kyse tai haluat verestää HTML-muistiasi, nyt on hyvä hetki käydä lukemassa osoitteessa <a href="http://www.w3schools.com/html/default.asp" target="_blank">http://www.w3schools.com/html/default.asp</a> oleva HTML-opas.</p>

	    </aside>
	    
<!--	    
	    <p>Tarkastellaan edellä toteutettua sivun palauttamista vielä tarkemmin.</p>

<pre class="sh_java">
get("/", (req, res) -> {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    return new ModelAndView(map, "sivu");
}, new ThymeleafTemplateEngine());
</pre>

            <p>Ensimmäisellä rivillä kerromme, että juuripolkuun tulevat pyynnöt tulee käsitellä seuraavasti. Tätä seuraa pyynnön käsittelyyn liittyvä lohko, josta palautetaan olio, joka sisältää <code>HashMap</code>-olion sekä tiedon näytettävästä html-sivusta. Tämän jälkeen pyynnön käsittelyyn lisätään vielä erillinen olio, <code>ThymeleafTemplateEngine</code>, joka käsittelee html-sivun ennen sen palautusta.</p>
-->

            <h3>Datan lisääminen näkymään</h3>

	    <p>Palvelinohjelmistossa luodun tai haetun datan lisääminen näkymään tapahtuu <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/ui/Model.html" target="_blank">Model</a>-tyyppisen olion avulla. Kun lisäämme Model-olion pyyntöjä käsittelevän metodin parametriksi, lisää Spring-sovelluskehys sen automaattisesti käyttöömme. </p>


<pre class="sh_java">
package thymeleafdata;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

public class ThymeleafJaDataController {

    @RequestMapping("/")
    public String home(Model model) {
        return "index";
    }
}
</pre>
      
	    <p>Model on Spring-sovelluskehyksen käyttämä Map-rajapinnan toimintaa muistuttava lokerikko, missä jokaisella lokerolla on nimi, mihin arvon voi asettaa. Alla olevassa esimerkissä määrittelemme pyyntöjä käsittelevälle metodille Model-olion, jonka jälkeen lisäämme lokeroon nimeltä <code>teksti</code> arvon <code>"Hei mualima!"</code>.</p>


<pre class="sh_java">
package thymeleafdata;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ThymeleafJaDataController {

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("teksti", "Hei mualima!");
        return "index";
    }
}
</pre>

	    <p>Kun käyttäjä tekee pyynnön, joka ohjautuu ylläolevaan metodiin, ohjautuu pyyntö <code>return</code>-komennon jälkeen Thymeleafille, joka saa käyttöönsä myös Model-olion ja siihen lisätyt arvot.</p>

	    <h3>Sivun käsittely Thymeleafissa</h3>
	    
	    <p>Oletetaan, että käytössämme olevan <code>index.html</code>-sivun lähdekoodi on seuraavanlainen:</p>
	    
<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p>Kun Thymeleaf käsittelee HTML-sivun, se etsii sieltä elementtejä, joilla on <code>th:</code>-alkuisia attribuutteja. Ylläolevasta sivusta Thymeleaf löytää <code>h2</code>-elementin, jolla on attribuutti <code>th:text</code> -- <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>. Attribuutti <code>th:text</code> kertoo Thymeleafille, että elementin tekstiarvo (testi) tulee korvata attribuutin arvon ilmaisemalla muuttujalla. Attribuutin <code>th:text</code> arvona on <code>${teksti}</code>, jolloin Thymeleaf etsii <code>model</code>-oliosta avaimella <code>"teksti"</code> arvoa.</p>
	    
	    <p>Käytännössä Thymeleaf etsii siis Model-oliosta lokeron nimeltä <code>teksti</code> ja asettaa siinä olevan arvon <code>h2</code>-elementin tekstiarvoksi. Tässä tapauksessa teksti <code>testi</code> korvataan Model-olion lokerosta teksti löytyvällä arvolla, eli tekstillä <code>Hei mualima!</code>.</p>
	    
	    <p></p>
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellomodel">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellomodel">
                      Hello Model
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellomodel" class="collapse">
		  
		  <p>Tehtäväpohjan mukana tulevaan HTML-tiedostoon on toteutettu tarina, joka tarvitsee otsikon ja päähenkilön. Toteuta pakkauksessa <code>wad.hellomodel</code> sijaitsevaan <code>HelloModelController</code>-luokkaan toiminnallisuus, joka käsittelee juuripolkuun tulevia pyyntöjä ja käyttää pyynnössä tulevia parametreja tarinan täydentämiseen. Voit olettaa, että pyynnön mukana tulevien parametrien nimet ovat <code>title</code> ja <code>person</code>.</p>
		  
		  <p>Lisää pyynnön mukana tulevien parametrien arvot Thymeleafille annettavaan HashMappiin. Otsikon avaimen tulee olla <code>"title"</code> ja henkilön avaimen tulee olla <code>"person"</code>. Palautettava sivu on <code>index.html</code>.</p>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun juuripolkuun tehdyssä pyynnössä on annettuna otsikoksi <code>Mökkielämää</code> ja henkilöksi <code>Leena</code>.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex6.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    <h2>Tiedon lähettäminen palvelimelle</h2>
	    
	    
            <p>HTML-sivuille voi määritellä lomakkeita (<a href="http://www.w3schools.com/html/html_forms.asp" target="_blank">form</a>), joiden avulla käyttäjä voi lähettää tietoa palvelimelle. Lomakkeen määrittely tapahtuu <code>form</code>-elementin avulla, jolle kerrotaan polku, mihin lomake lähetetään (action), sekä pyynnön tyyppi (method). Pidämme pyynnön tyypin toistaiseksi GET-tyyppisenä.</p>
	    
	    <p>Lomakkeeseen voidaan määritellä mm. tekstikenttiä (<code>&lt;input type="text"...</code>) sekä painike, jolla lomake lähetetään (<code>&lt;input type="submit"...</code>). Alla tekstikentän <code>name</code>-attribuutin arvoksi on asetettu <code>nimi</code>. Tämä tarkoittaa sitä, että kun lomakkeen tiedot lähetetään palvelimelle, tulee pyynnössä <code>nimi</code>-niminen parametri, jonka arvona on tekstikenttään kirjoitettu teksti.</p>

<pre class="sh_xml">
&lt;form th:action="@{/}" method="GET"&gt;
    &lt;input type="text" name="nimi"/&gt;
    &lt;input type="submit"/&gt;
&lt;/form&gt;</pre>

	    <aside class="info">
	      <br/>
	      <h1>Wut, th:action?</h1>

	      <p>Jos HTML-lomakkeet ovat sinulle tuttuja, saatoit huomata, että ylläolevassa lomakkeessa polku on määritelty attribuutin <code>th:action</code> avulla. Polku on lisäksi <code>@{<em>polku</em>}</code> <code>@</code>-merkin sekä aaltosulkujen sisällä -- <code>@{<em>polku</em>}</code>.</p>

	      <p>Tämän avulla varaudumme tilanteeseen, missä palvelimella voi olla useampia sovelluksia samaan aikaan. Tällöin ohjelmoimamme sovellus voi sijaita esimerkiksi polussa <code>http://osoite.com/sovellus1/</code> ja sovelluskehyksemme päättelee polun automaattisesti.</p>
	    </aside>

	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloform">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloform">
                      Hello Form
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloform" class="collapse">
		  
		  <p>Tehtäväpohjassa on toiminnallisuus, jonka avulla sivulla voi näyttää tietoa, ja jonka avulla sivulta lähetetty tieto voidaan myös käsitellä. Tiedon lähettämiseen tarvitaan sivulle kuitenkin lomake.</p>
		  
		  <p>Toteuta tehtäväpohjan kansiossa <code>src/main/resources/templates</code> olevaan <code>index.html</code>-tiedostoon lomake. Lomakkeessa tulee olla tekstikenttä, jonka nimen tulee olla <code>content</code>. Tämän lisäksi, lomakkeessa tulee olla myös nappi, jolla lomakkeen voi lähettää. Lomakkeen tiedot tulee lähettää juuriosoitteeseen GET-tyyppisellä pyynnöllä.</p>
		  
		  <p>Kun sovellus toimii oikein, voit vaihtaa sivulla näkyvää otsikkoa lomakkeen avulla.</p>
		  
                </div>
              </div>
            </div>

	    <aside class="info">
	      <br/>
	      <h1>Pyynnön parametrit</h1>

	      <p>Annotaatiolle <code>RequestParam</code> voi asettaa myös attribuutteja, joiden perusteella voidaan määritellä pyynnön parametrien pakollisuutta tai oletusarvoja. Katso edellisen tehtävän kontrolleriluokasta esimerkkiä.</p>
	    </aside>
	    

	    <h2>Listojen käsittely</h2>


	    <p>Thymeleafille annettavalle Model-oliolle voi asettaa tekstin lisäksi myös arvokokoelmia. Alla luomme "pääohjelmassa" listan, joka asetetaan Thymeleafin käsiteltäväksi menevään Model-olioon jokaisen juuripolkuun tehtävän pyynnön yhteydessä. Jos juuripolkuun lähetetään parametri nimeltä <code>"content"</code>, lisätään se myös listaan -- alla parametri on määritelty ei-pakolliseksi annotaation <code>@RequestMapping</code> attribuutilla <code>required = false</code>.</p>

<pre class="sh_java">
package thymeleafdata;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class ListaController {
    private List&lt;String&gt; lista;

    public ListaController() {
        this.lista = new ArrayList&lt;&gt;();
        this.lista.add("Hello world!");
    }

    @RequestMapping(value = "/")
    public String home(Model model, 
            @RequestParam(required = false) String content) {
        if(content != null && !content.trim().isEmpty()) {
            this.lista.add(content);
        }

        model.addAttribute("list", lista);
        return "index";
    }
}
</pre>

	    <p>Listan läpikäynti Thymeleafissa tapahtuu attribuutin <code>th:each</code> avulla. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on seuraavanlainen.</p>

<pre class="sh_xml">
&lt;pre&gt;
    &lt;p th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/p&gt;
&lt;/pre&gt;</pre>

            <p>Yllä käytämme attribuuttia nimeltä <code>lista</code> ja tulostamme yksitellen sen sisältämät alkiot. Attribuutin <code>th:each</code> voi asettaa käytännössä mille tahansa toistettavalle elementille. Esimerkiksi HTML-listan voisi tehdä seuraavalla tavalla.</p>

            <pre class="sh_xml">
&lt;ul&gt;
    &lt;li th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre>


            <p><em>Huom! Eräs klassinen virhe on määritellä iteroitava joukko merkkijonona <code>th:each="alkio : lista"</code>. Tämä ei luonnollisesti toimi.</em></p>

	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellolist">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellolist">
                      Hello List
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellolist" class="collapse">
		  
		  <p>Tehtäväpohjassa on palvelinpuolen toiminnallisuus, jossa käsitellään juuripolkuun tuleva pyyntö, sekä lisätään lista Thymeleafille sivun käsittelyyn. Tehtäväpohjaan liittyvä HTML-sivu ei kuitenkaan sisällä juurikaan toiminnallisuutta.</p>
		  
		  <p>Lisää HTML-sivulle (1) listalla olevien arvojen tulostaminen <code>th:each</code>-komennon avulla ja (2) lomake, jonka avulla palvelimelle voidaan lähettää uusia arvoja.</p>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun sivulle on lisätty muutama rivi lomakkeen avulla. Viimeisimpänä on juuri lisätty teksti "Hello?".</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex8.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    

	    <div class="tehtavat">
	      <div class="tehtava" id="t-notebook">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-notebook">
                      Notebook
                    </a>
                  </h1>
                </header>
		
                <div id="t-notebook" class="collapse">
		  
		  <p>Toteuta tehtäväpohjan pakkauksessa <code>wad.notebook</code> olevaan <code>NotebookController</code>-luokkaan muistio-ohjelma, jolle voi lisätä muistiinpanoja. Tee ohjelmastasi sellainen, että jos muistiinpanoja on yli 10, se muistaa ja näyttää niistä vain viimeisimmät 10.</p>
		  
		  <p>Alla on esimerkki muistiosta, kun siihen on lisätty 3 viestiä.</p>
		  
		  <p><img class="browser-img" src="img/mooc/ex9.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    
	    
	    
	    <h2>Pyynnön uudelleenohjaus ja POST</h2>
	    
	    <p>Olemme tähän mennessä toteuttaneet palvelinohjelmistoihimme vain kyvyn käsitellä GET-tyyppisiä pyyntöjä. GET-tyyppisiä pyyntöjä käytetään ensisijaisesti tiedon hakemiseen, eikä niitä oikeastaan pitäisi käyttää laisinkaan tiedon muuttamiseen. Toinen tapa lähettää tietoa palvelimelle on <code>POST</code>-tyyppiset pyynnöt, joita käytettäessä pyynnön parametrit kulkevat pyynnön <em>rungossa</em> -- palaamme pyynnön erilaisiin muotoihin myöhemmin kurssilla.</p>
	    
            <p>Oikeastaan kaikki pyynnöt, joissa lähetetään tietoa palvelimelle, ovat ongelmallisia jos pyynnön vastauksena palautetaan näytettävä sivu. Tällöin käyttäjä voi sivun uudelleenlatauksen (esim. painamalla F5) yhteydessä lähettää aiemmin lähettämänsä datan vahingossa uudelleen. Kokeile tätä jossain aiemmassa tehtävässä kun olet lähettänyt lomakkeella tietoa!</p>
	    
            <p>On tyylikkäämpää toteuttaa lomakkeen dataa vastaanottava toiminnallisuus siten, että lähetetyn tiedon käsittelyn jälkeen käyttäjälle palautetaan vastauksena uudelleenohjauspyyntö. Tämän jälkeen käyttäjän selain tekee uuden pyynnön uudelleenohjauspyynnön mukana annettuun osoitteeseen. Tätä toteutustapaa kutsutaan <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank">Post/Redirect/Get</a>-suunnittelumalliksi ja sillä mm. estetään lomakkeiden uudelleenlähetys, jonka lisäksi vähennetään toiminnallisuuden toisteisuutta.</p>

	    <h3>POST-pyynnön kuuntelu ja uudelleenohjaus</h3>
	    
	    <p>Alla on toteutettu POST-tyyppistä pyyntöä kuunteleva polku sekä siihen liittyvä toiminnallisuus. Pyynnön tyyppi määritellään annotaation @RequestMapping attribuutiksi (method-attribuutti). Tällöin kuunneltava polku tulee määritellä myös tarkemmin (value-attribuutti). Palauttamalla pyyntöä käsittelevästä metodista merkkijono <code>redirect:/</code> kerrotaan, että pyynnölle tulee lähettää vastauksena uudelleenohjauspyyntö polkuun <code>"/"</code>. Kun selain vastaanottaa uudelleenohjauspyynnön, tekee se GET-tyyppisen pyynnön uudelleenohjauspyynnössä annettuun osoitteeseen.</p>

<pre class="sh_java">
package uudelleenohjaus;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class ListaController {
    private List&lt;String&gt; lista;

    public ListaController() {
        this.lista = new ArrayList&lt;&gt;();
        this.lista.add("Hello world!");
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", lista);
        return "index";
    }

    @RequestMapping(value = "/", method = RequestMethod.POST)
    public String post(@RequestParam String content) {
        if(!content.trim().isEmpty()) {
            this.lista.add(content);
        }

        return "redirect:/";
    }
}
</pre>
	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellopostredirectget">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopostredirectget">
                      Hello POST/Redirect/GET
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellopostredirectget" class="collapse">
		  
		  <p>Tehtäväpohjassa on sekä muistilappujen listaamistoiminnallisuus, että lomake, jonka avulla voidaan lähettää POST-tyyppisiä pyyntöjä palvelimelle. Toteuta sovellukseen toiminnallisuus, missä palvelin kuuntelee POST-tyyppisiä pyyntöjä, lisää pyynnön yhteydessä tulevan tiedon sovelluksessa olevaan listaan ja uudelleenohjaa käyttäjän tekemään GET-tyyppisen pyynnön juuriosoitteeseen.</p>
		  
                </div>
              </div>
            </div>
	    

	    <h2>Olioita kaikkialla!</h2>
	    
	    <p>Thymeleafille annettavaan Modeliin voi hyvin lisätä myös olioita. Oletetaan, että käytössämme on henkilöä kuvaava luokka.</p>
	    
<pre class="sh_java">
public class Henkilo {
    private String nimi;

    public Henkilo(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}
</pre>

	    <p>Henkilo-olion lisääminen on suoraviivaista:</p>

<pre class="sh_java">
    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("henkilo", new Henkilo("Le Pigeon"));
        return "index";
    }
</pre>

	    <p>Kun sivua luodaan, henkilöön päästään käsiksi modeliin asetetun avaimen perusteella. Edellä luotu "Le Pigeon"-henkilö on tallessa avaimella "henkilo". Kuten aiemminkin, avaimella pääsee olioon käsiksi.</p>
	    
	    
<pre class="sh_xml">
&lt;h2 th:text="${henkilo}"&gt;Henkilön nimi&lt;/h2&gt;</pre>

	    <p>Ylläolevaa henkilön tulostusta kokeillessamme saamme näkyville (esim.) merkkijonon <code>Henkilo@29453f44</code> -- ei ihan mitä toivoimme. Käytännössä Thymeleaf kutsuu edellisessä tapauksessa olioon liittyvää <code>toString</code>-metodia, jota emme ole määritelleet. Pääsemme oliomuuttujiin käsiksi olemassaolevien <code>get<em>Muuttuja</em></code>-metodien kautta. Jos haluamme tulostaa Henkilo-olioon liittyvän nimen, kutsumme metodia <code>getNimi</code>. Thymeleafin käyttämässä notaatiossa kutsu muuntuu muotoon <code>henkilo.nimi</code>. Saamme siis halutun tulostuksen seuraavalla tavalla:</p>

<pre class="sh_xml">
&lt;h2 th:text="${henkilo.nimi}"&gt;Henkilön nimi&lt;/h2&gt;</pre>

	    <p></p>

	    <h3>Olioita listalla</h3>
	    
	    <p>Listan läpikäynti Thymeleafissa tapahtuu attribuutin <code>th:each</code> avulla. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on jo tullut aiemmin tutuksi.</p>
	    
<pre class="sh_xml">
&lt;pre&gt;
    &lt;p th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/p&gt;
&lt;/pre&gt;</pre>

            <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi aivan samalla tavalla kuin muiden olioiden ominaisuuksiin. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi henkilöä, lista lisätään pyyntöön ja lopulta luodaan näkymä Thymeleafin avulla.</p>

<pre class="sh_java">
package henkilot;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HenkiloController {
    private List&lt;Henkilo&gt; henkilot;

    public ListaController() {
        this.henkilot = new ArrayList&lt;&gt;();
        this.henkilot.add(new Henkilo("James Gosling"));
        this.henkilot.add(new Henkilo("Martin Odersky"));
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", henkilot);
        return "index";
    }
}
</pre>

                <pre class="sh_xml">
&lt;p&gt;Ja huomenna puheet pitävät:&lt;/p&gt;
&lt;ol&gt;
    &lt;li th:each="henkilo : ${list}"&gt;
        &lt;span th:text="${henkilo.nimi}"&gt;Esimerkkihenkilö&lt;/span&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</pre>

            <p>Käyttäjälle lähetettävä sivu näyttää palvelimella tapahtuneen prosessoinnin jälkeen seuraavalta.</p>

<pre class="sh_xml">
&lt;p&gt;Ja huomenna puheet pitävät:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;span&gt;James Gosling&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;Martin Odersky&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</pre>

	    <p></p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloobjects">

		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloobjects">
                      Hello Objects
                    </a>
                      </h1>
                </header>

                <div id="t-helloobjects" class="collapse">

		  <p>Tehtäväpohjassa on sovellus, jossa käsitellään <code>Item</code>-tyyppisiä olioita. Tehtävänäsi on lisätä sovellukseen lisätoiminnallisuutta:</p>
		  
		  <ul>
		    <li>Kun käyttäjä avaa selaimella sovelluksen juuripolun, tulee hänen lomakkeen lisäksi nähdä lista esineistä. Jokaisesta esineestä tulee tulla ilmi sen nimi (name) ja tyyppi (type).</li>
		    <li>Kun käyttäjä lähettää lomakkeella uuden esineen palvelimelle, tulee palvelimen säilöä esine listalle seuraavaa näyttämistä varten. Huomaa, että lomake lähettää tiedot POST-pyynnöllä sovelluksen juureen. Kun esine on säilötty, uudelleenohjaa käyttäjän pyyntö siten, että käyttäjän selain tekee GET-tyyppisen pyynnön sovelluksen juuripolkuun.</li>
		  </ul>
		  
		  <p>Allaolevassa esimerkissä sovellukseen on lisätty olemassaolevan taikurin hatun lisäksi <a href="https://en.wikipedia.org/wiki/Party_hat" target="_blank">Party hat</a>, eli bilehattu.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex11.png"/></p>

                </div>
              </div>
            </div>


	    <h2>Polkumuuttujat</h2>

	    <p>Polkuja käytetään erilaisten resurssien tunnistamiseen ja yksilöintiin. Usein kuitenkin vastaan tulee tilanne, missä luodut resurssit ovat uniikkeja, emmekä niiden tietoja ennen sovelluksen käynnistymistä. Jos haluaisimme näyttää tietyn resurssin tiedot, voisimme lisätä pyyntöön parametrin -- esim <code>esineet?tunnus=3</code>, minkä arvo olisi haetun resurssin tunnus.</p>

	    <p>Toinen vaihtoehto on ajatella polkua haettavan resurssin tunnistajana. Annotaatiolle <code>@RequestMapping</code> määriteltävään polkuun voidaan määritellä polkumuuttuja aaltosulkujen avulla. Esimerkiksi polku <code>"/{arvo}"</code> ottaisi vastaan minkä tahansa juuripolun alle tulevan kyselyn ja tallentaisi arvon myöhempää käyttöä varten. Tällöin jos käyttäjä tekee pyynnön esimerkiksi osoitteeseen <code>http://localhost:8080/kirja</code>, tallentuu arvo "kirja" myöhempää käyttöä varten. Polkumuuttujiin pääsee käsiksi pyyntöä käsittelevälle metodille määriteltävän annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html" target="_blank">@PathVariable</a> avulla.</p>

	    <p>Yksittäisen henkilön näyttäminen onnistuisi esimerkiksi seuravavasti:</p>

<pre class="sh_java">
package henkilot;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HenkiloController {
    private List&lt;Henkilo&gt; henkilot;

    public ListaController() {
        this.henkilot = new ArrayList&lt;&gt;();
        this.henkilot.add(new Henkilo("James Gosling"));
        this.henkilot.add(new Henkilo("Martin Odersky"));
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", henkilot);
        return "index";
    }

    @RequestMapping("/{id}")
    public String getOne(Model model, @PathVariable Integer id) {
        if(id &lt; 0 || id &gt;= this.henkilot.size()) {
            return home(model);
        }

        model.addAttribute("henkilo", henkilot.get(id));
        return "henkilo";
    }
}
</pre>

	    <p></p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellopathvariables">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopathvariables">
                      Hello Path Variables
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellopathvariables" class="collapse">

		  <p>Tehtäväpohjassa on sovellus, jossa käsitellään taas edellisestä tehtävästä tuttuja <code>Item</code>-tyyppisiä olioita. Tällä kertaa esineet kuitenkin kuvastavat hattuja. Kun sovelluksen juureen tehdään pyyntö, käyttäjälle näytetään oletushattu ("default"). Lisää sovellukseen toiminnallisuus, minkä avulla tiettyyn polkuun tehtävä kysely palauttaa sivun, jossa näkyy tietyn hatun tiedot -- huomaa, että voit asettaa polkumuuttujan tyypiksi myös Stringin.</p>
		  
		  <p>Sovelluksen juuripolkuun tehtävä pyyntö näyttää seuraavanlaisen sivun:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex12-default.png"/></p>

		  <p>Muihin osoitteisiin tehtävät pyynnöt taas palauttavat tehtäväpohjassa olevasta <code>items</code>-hajautustaulusta polkuun sopivan hatun. Esimerkiksi pyyntö polkuun <code>/ascot</code> näyttää seuraavanlaisen sivun:</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex12-ascot.png"/></p>

                </div>
              </div>
            </div>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloindividualpages">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloindividualpages">
                      Hello Individual Pages
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloindividualpages" class="collapse">
		  
		  <p>Edellisessä tehtävässä käytössämme oli vain yksi sivu. Olisi kuitenkin hienoa, jos jokaiselle hatulle olisi oma sivu -- ainakin sovelluksen käyttäjän näkökulmasta.</p>
		  
		  <p>Tehtäväpohjassa on valmiina sovellus, joka listaa olemassaolevat hatut ja näyttää ne käyttäjälle. Jokaisen hatun yhteydessä on linkki, jota klikkaamalla pitäisi päästä hatun omalle sivulle.</p>
		  
		  <p>Toteuta sekä html-sivu (<code>single.html</code>), että sopiva metodi, joka ohjaa pyynnön sivulle.</p>
		  

		  <p>Pyyntö sovelluksen juureen luo seuraavanlaisen sivun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex13-list.png"/></p>
		  
		  <p>Jos sivulta klikkaa hattua, pääsee tietyn hatun tiedot sisältävälle sivulle. Alla olevassa esimerkissä on klikattu taikurin hattuun liittyvää linkkiä.</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex13-single.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-todoapplication">

		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-todoapplication">
                      Todo Application
                    </a>
                  </h1>
                </header>
		
                <div id="t-todoapplication" class="collapse">
		  
		  <p>Tässä tehtävässä tulee rakentaa tehtävien hallintaan tarkoitettu sovellus. Sovelluksen käyttämät sivut ovat valmiina näkyvissä, itse sovelluksen pääset toteuttamaan itse.</p>
		  
		  <p>Sovelluksen tulee sisältää seuraavat toiminnallisuudet:</p>
		  
		  <ul>
		    <li>Kaikkien tehtävien listaaminen. Kun käyttäjä tekee pyynnön sovelluksen juuripolkuun, tulee hänelle näyttää sivu, missä tehtävät on listattuna. Sivulla on myös lomake tehtävien lisäämiseen. </li>
		    <li>Yksittäisen tehtävän lisääminen. Kun käyttäjä täyttää lomakkeen sivulla ja lähettää tiedot palvelimelle, tulee sovelluksen lisätä tehtävä näytettävään listaan.</li>
		    <li>Yksittäisen tehtävän poistaminen. Kun käyttäjä painaa tehtävään liittyvää <code>Done!</code>-nappia, tulee tehtävä poistaa listalta. Toteuta tämä niin, että metodin tyyppi on <code>DELETE</code>:
<pre class="sh_java">
@RequestMapping(value = "/{item}", method = RequestMethod.DELETE)</pre></li>
		    <li>Yksittäisen tehtävän näyttäminen. Kun käyttäjä klikkaa tehtävään liittyvää linkkiä, tulee käyttäjälle näyttää tehtäväsivu. Huom! Tehtävään liittyvien tarkistusten määrä tulee kasvaa aina yhdellä kun sivulla vieraillaan.</li>
		  </ul>
		  
		  <p>Alla kuva tehtävien listauksesta:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-list.png"/></p>
		  
		  <p>Kun tehtävää klikkaa, näytetään erillinen tehtäväsivu:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-item-1.png"/></p>
		  
		  <p>Kun sivu avataan toisen kerran, kasvaa tehtävien tarkistukseen liittyvä laskuri:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-item-2.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    

	    <h2>Tiedon tallentaminen</h2>

	    <p>Sovelluksemme -- vaikka huikeita ovatkin -- ovat melko alkeellisia, sillä sovelluksissa käsiteltävää tietoa ei tallenneta mihinkään. Esimerkiksi lomakkeen avulla sovellukselle lähetettävä data katoaa kun sovellus käynnistetään uudestaan. Tämä ei ole kivaa.</p>

	    <p>Tietokannat ovat palvelinohjelmistosta erillisiä sovelluksia, joiden ensisijainen tehtävä on varmistaa, että käytettävä tieto ei katoa. Otetaan ensiaskeleet tietokannan käyttöön web-palvelinohjelmistoissa -- tutustumme tietokantoihin tarkemmin myöhemmin kurssilla. Käytämme tietokantatoiminnallisuuden toteuttamisessa <a href="http://projects.spring.io/spring-data-jpa/" target="_blank">Spring Data JPA</a>-komponenttia, johon löytyy myös aloituspaketti käyttämästämme Spring Bootista.</p>

	    <aside class="info">

	      <br/>

	      <h1>Spring Data JPA:n käyttöönotto</h1>
		  
	      <p>Saadaksemme Spring Data JPA:n käyttöömme, tulee meidän lisätä se <code>pom.xml</code>-tiedostoon. Spring Bootin kautta löytyy näppärä paketti <code>spring-boot-starter-data-jpa</code>, joka vähentää yksittäisten riippuvuuksien lisäämistä. Tämän lisäksi tarvitsemme testikäyttöön sopivan tietokannan -- valitaan <a href="http://www.h2database.com/" target="_blank">H2 Database</a>, jonka voi ladata muistiin sovelluksen käynnistyessä.</p>

	      <p>Lisätään projektiin seuraavat riippuvuudet:</p>

	      <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

	      <p>Kun projektin riippuvuudet noudetaan Mavenin avulla, on tietokanta valmis testikäyttöön.</p>

	    </aside>


	    <h3>Tietokantaan tallennettavat oliot eli entiteetit</h3>

            <p>Käytämme ORM-kirjastoa (object relational mapping), jonka tehtävänä on muuntaa oliot tietokantaan tallennettavaan muotoon. Karkeasti ajatellen luokka vastaa tietokantataulua ja oliomuuttujat vastaavat tietokannan sarakkeita. Jokainen taulun rivi vastaa yhtä luokasta tehtyä oliota.</p>

	    <p>Luokat, joista tehdyt oliot voidaan tallentaa tietokantaan, tulee annotoida <code>@Entity</code>-annotaatiolla. Tämän lisäksi luokille tulee määritellä tunnuskenttä, jonka avulla niihin liittyvät oliot voidaan yksilöidä. Voimme käyttää tunnuskentän luomiseen valmista <code>AbstractPersistable</code>-yliluokkaa, jota perittäessä kerromme uniikin tunnuksen tyypin. Esimerkiksi <code>Henkilo</code>-luokasta voidaan tehdä tietokantaan tallennettava seuraavilla muutoksilla.</p>

                <pre class="sh_java">
package wad.domain;

import javax.persistence.Entity;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}</pre>

            <p>Kun käytössämme on tietokantaan tallennettava luokka, voimme luoda tietokannan käsittelyyn käytettävän <em>rajapinnan</em>. Kutsutaan tätä rajapintaoliota nimellä <code>HenkiloRepository</code>.</p>

                <pre class="sh_java">
// pakkaus

import wad.domain.Henkilo;
import org.springframework.data.jpa.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {

}</pre>

            <p>Rajapinta perii Spring Data-projektin <code>JpaRepository</code>-rajapinnan; samalla kerromme, että tallennettava olio on tyyppiä <code>Henkilo</code> ja että tallennettavan olion tunnus on <code>Long</code>-tyyppiä. Tämä tyyppi on sama kuin aiemmin <code>AbstractPersistable</code>-luokan perinnässä parametriksi asetettu tyyppi. Spring osaa käynnistyessään etsiä mm. JpaRepository-rajapintaluokan periviä luokkia. Jos niitä löytyy, se luo niiden pohjalta tietokannan käsittelyyn sopivan olion sekä asettaa olion ohjelmoijan haluamiin muuttujiin.</p>

	    <p>Nämä muuttujat tulee määritellä <code>@Autowired</code>-annotaatiolla -- jokaiselle muuttujalle tulee oma annotaatio -- palaamme myöhemmin kurssilla tarkemmin tähän ns. olioiden automaattiseen asettamiseen.</p>

            <p>Kun olemme luoneet rajapinnan <code>HenkiloRepository</code>, voimme lisätä sen käyttöömme esimerkiksi kontrolleriluokkaan. Tämä tapahtuu seuraavasti.</p>

                <pre class="sh_java">
// ...

@Controller
public class HenkiloController {

    @Autowired
    private HenkiloRepository henkiloRepository;

    // ...
}</pre>

            <p>Nyt tietokantaan pääsee käsiksi <code>HenkiloRepository</code>-olion kautta. Osoitteessa <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html</a> on JpaRepository-rajapinnan API-kuvaus, mistä löytyy rajapinnan tarjoamien metodien kuvauksia. Voimme esimerkiksi toteuttaa tietokannassa olevien olioiden listauksen sekä yksittäisen olion haun seuraavasti:</p>

            <pre class="sh_java">
// ...

@Controller
public class HenkiloController {

    @Autowired
    private HenkiloRepository henkiloRepository;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("list", henkiloRepository.findAll());
        return "henkilot"; // erillinen henkilot.html
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable Long id) {
        model.addAttribute("henkilo", henkiloRepository.findOne(id));
        return "henkilo"; // erillinen henkilo.html
    }
}</pre>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellodatabase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodatabase">
                      Hello Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodatabase" class="collapse">
		  
		  <p>Tässä tehtävässä on valmiiksi toteutettuna tietokantatoiminnallisuus sekä esineiden noutaminen tietokannasta. Lisää sovellukseen toiminnallisuus, jonka avulla esineiden tallentaminen tietokantaan onnistuu valmiiksi määritellyllä lomakkeella.</p>
		  
		  <p>Alla esimerkki sovelluksesta kun tietokantaan on lisätty muutama rivi:</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex15.png"/></p>
		  
                </div>
              </div>
            </div>		
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-tododatabase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-tododatabase">
                      Todo Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-tododatabase" class="collapse">
		  
		  <p>Luo tässä TodoApplication-tehtävässä nähty tehtävien hallintaan tarkoitettu toiminnallisuus mutta siten, että tehtävät tallennetaan tietokantaan. Tässä tehtävässä entiteettiluokan nimen tulee olla <code>Item</code> ja avaimen tyypin tulee olla <code>Long</code>: <pre class="sh_java">
@Entity
public class Item extends AbstractPersistable&lt;Long&gt; {
...</pre></p>
		  <p>Noudata lisäksi HTML-sivujen rakennetta ja toiminnallisuutta.</p>
		  
                </div>
              </div>
            </div>
	    

	  </section>
	  <!-- END OSA1 -->

          <!-- BEGIN OSA2 -->
          <section class="weeklimit" data-week-id="2">
	    
            <header>
              <h1 id="osa2">Osa 2</h1>
            </header>

	    <p>Aloitamme toisen osan edellisen viikon kertauksella, jonka jälkeen syvennymme internetin perusosiin. Tätä seuraa tarkempi tutustuminen tietokantojen käyttöön sekä web-sovellusten rakenteeseen.</p>

	    <aside class="info">
	      <br/>
	      <h1>Muutosten automaattinen päivittäminen sivulle</h1>

	      <p>Muutamat ovat kysyneet miten ohjelmakoodissa tehdyt muutokset saa automaattisesti päivittymään selaimeen. Javalla toimivat ohjelmat käynnistetään tavukoodiksi, ja nämä tavukoodit suoritetaan ohjelmaa käynnistettäessä, joten automaattinen siirto ei ole täysin suoraviivaista.</p>

	      <p>Tähän löytyy kuitenkin asian osittain ratkaiseva projekti, <code>spring-boot-devtools</code>, joka tarjoaa välineitä ohjelmistokehitysprosessin nopeuttamiseksi.</p>

	      <p>Projektin lisääminen Maveniin tapahtuu seuraavan riippuvuuden avulla:</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;
&lt;/dependency&gt;
</pre>

	      <p>Kun ylläoleva riippuvuus on lisätty projektiin, käynnistetään ohjelman käynnistyksen yhteydessä myös <a href="http://livereload.com/" target="_blank">LiveReload</a>-palvelin. Kun selaimeen asentaa LiveReload-liitännäisen (Chromelle osoitteesta <a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank">https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei</a>) ja kytkee liitännäisen päälle, LiveReload-liitännäinen ja palvelin keskustelevat toistensa kanssa ja päivittävät näkymää tarvittaessa.</p>

	      <p>Devtools-projektin lisääminen sovellukseen johtaa myös siihen, että sovellus ladataan uudestaan aina kun sen lähdekoodi muuttuu. Tämän lisäksi osoitteessa <code>http://localhost:8080/h2-console</code> on tietokantakonsoli, jonka avulla voi käydä tarkastelemassa tietokannan tilaa. Huom! Tämä toimii vain, jos käytössä on H2-tietokantamoottori.</p>

	    </aside>
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-osa1-kertaus-ex" data-count="17">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-osa1-kertaus">
                      Osa 1, kertaus: Jobs
                    </a>
                  </h1>
                </header>
		
                <div id="t-osa1-kertaus" class="collapse">
		  
		  <p>Jokainen uusi osio alkaa edellisen viikon teemoja sisältävällä kertaustehtävällä. Uusi osio tulee näkyville kun teet vähintään 50% edellisen osion tehtävistä. </p>
		  
		  <p>Ensimmäisessä kertaustehtävässä tehtävänäsi on toteuttaa sovellus työlistan hallintaan. Työlistalla näkyy ne työt, jotka eivät ole vielä tehtynä. Työn voi merkitä tehdyksi "Done!" -nappia painamalla.</p>
		  
		  <img src="img/2016-mooc/ex17-jobs.png" class="browser-img"/>
		  
		  <p>Kun työ merkitään tehdyksi, siirretään se erilliseen aiempia töitä listaavaan tauluun.</p>
		  
		  <img src="img/2016-mooc/ex17-jobs-done.png" class="browser-img"/>
		  
		  <p>Tehtäväpohjassa on annettu valmiina käyttöliittymän HTML-koodi, mistä voi tarkastella myös haluttua toiminnallisuutta.</p>
		  
                </div>
              </div>
	    </div>
	    
	    
            <h1 data-count="2">Internetin perusosat</h1>

	    <p>Internetin peruskomponentit ovat (1) palveluiden, palvelinohjelmistojen ja resurssien yksilöintiin käytetyt merkkijonomuotoiset osoitteet (<em>URI, Uniform Resource Identifier</em>) sekä näiden merkkijonomuotoisten verkko-osoitteiksi käytettävä palvelu (<em>DNS, Domain Name Services</em>), (2) selainten ja palvelinten välisessä viestittelyssä käytettävä viestimuoto (protokolla) (<em>HTTP, HyperText Transfer Protocol</em>), sekä (3) yhteinen dokumenttien esityskieli (<em>HTML, HyperText Markup Language</em>).</p>
		
            <h2>URI ja DNS: Osoitteet ja niiden tulkinta</h2>

            <p>Verkossa sijaitseva resurssi tunnistetaan osoitteen perusteella. Osoite (URI eli Uniform Resource Identifier, myös terminä käyttöön jäänyt URL <em>Uniform Resource Locator</em>) koostuu resurssin nimestä ja sijainnista, joiden perusteella haluttu resurssi ja palvelin (sijainti) voidaan löytää verkossa olevien koneiden massasta.</p>

            <p>Käytännössä URI-osoitteet näyttävät seuraavilta:</p>
	    
<pre>
protokolla://isäntäkone[:portti]/polku/../[kohdedokumentti[.paate]][?parametri=arvo&amp;toinen=arvo][#ankkuri]
</pre>

            <p>
              <ul>
                <li>protokolla: kyselyssä käytettävä protokolla, esimerkiksi HTTP, FTP tai SSH.</li>
                <li>isäntäkone: kone tai palvelin johon luodaan yhteys. Voi olla joko IP-osoite tai tekstuaalinen kuvaus (esim www.cs.helsinki.fi).</li>
                <li>portti: portti isäntäkoneella johon yhteys luodaan. Selaimet olettavat, että palvelinohjelmisto kuuntelee pyyntöjä portissa 80.  Web-sovellluksilla HTTP-palvelimien oletusportti on 80. Jos palvelin käyttää eri porttinumeroa kuin 80, tulee se merkitä osoitteeseen. Portti käytännössä määrittelee prosessin eli sovelluksen, johon yritetään ottaa yhteyttä.</li>
                <li>polku: periaatteessa polku resurssiin palvelimella. Käytännössä (nykyään) myös palvelun osoite, johon palvelin osaa osoittaa. Usein palvelut toimivat erillisessä koneessa sisäverkossa, ja ulkoverkkoon näkyvä kone vain toimii ohjaajana eli proxynä oikeaan palveluun.</li>
                <li>kohdedokumentti: haettava resurssi, jos kohdedokumenttia ei ole määritelty palvelin päättelee oletusdokumentin. Usein index.html</li>
		<li>.paate: resurssiin liittyvä tiedostotyyppi, ei pakollinen. Esimerkiksi .html</li>
                <li>kyselyparametrit: koostuu avain-arvo -pareista, joiden avulla palvelimelle pystyy toteuttamaan lisätoiminnallisuutta. Kuhunkin avaimeen liittyvä arvo esitetään = -merkillä, avain-arvo -parit erotetaan toisistaan &-merkillä.</li>
                <li>ankkuri: kertoo mihin kohtaan dokumentissa tulee mennä.</li>
              </ul>
            </p>
	    
            <aside class="pohdi">
              <h1>Osoitteen osat</h1>
	      
              <p>Tutki osoitetta <a href="https://fi.wikipedia.org/wiki/OSI-malli" target="_blank">https://fi.wikipedia.org/wiki/OSI-malli</a>. Mitkä tai mikä ovat/on osoitteen:</p>
	      
              <ul>
                <li>protokolla</li>
                <li>isäntäkone</li>
                <li>portti</li>
                <li>polku</li>
                <li>kohdedokumentti</li>
                <li>kyselyparametrit</li>
                <li>ankkuri</li>
              </ul>
	      
              <p>Mitkä näistä puuttuvat?</p>
            </aside>


            <p>Kun käyttäjä kirjoittaa web-selaimen osoitekenttään osoitteen ja painaa enteriä, web-selain tekee kyselyn annettuun osoitteeseen. Koska tekstimuotoiset osoitteet ovat käytännössä vain ihmisiä varten, kääntää selain ensiksi halutun osoitteen IP-osoitteeksi. Jos IP-osoite on jo tietokoneen tiedossa esimerkiksi aiemmin osoitteeseen tehdyn kyselyjen takia, selain voi ottaa yhteyden IP-osoitteeseen. Jos IP-osoite taas ei ole tiedossa, tekee selain ensin kyselyn <a href="http://fi.wikipedia.org/wiki/DNS" target="_blank">DNS</a>-palvelimelle (<em>Domain Name System</em>), jonka tehtävänä on muuntaa tekstuaaliset osoitteet IP-osoitteiksi (esim. Tietojenkäsittelytieteen laitoksen kotisivu <code>http://www.cs.helsinki.fi</code> on IP-osoitteessa <code>128.214.166.78</code>).</p>

            <p>IP-osoitteet yksilöivät tietokoneet ja mahdollistavat koneiden löytämisen verkon yli. Käytännössä yhteys IP-osoitteen määrittelemään koneeseen avataan <a href="https://fi.wikipedia.org/wiki/OSI-malli" target="_blank">sovelluskerroksen</a> <a href="https://fi.wikipedia.org/wiki/HTTP" target="_blank">HTTP-protokollan</a> avulla kuljetuskerroksen <a href="https://fi.wikipedia.org/wiki/TCP" target="_blank">TCP-protokollan</a> yli. TCP-protokollan tehtävänä on varmistaa, että viestit pääsevät perille. Selain ei ota "suoraan" yhteyttä palvelinohjelmistoon, vaan välissä on tyypillisesti useita viestinvälityspalvelimia, jotka auttavat viestin perillepääsemisessä -- lisää tietoa konkreettisesta tietoliikenteestä löytyy kurssilla <a href="http://www.cs.helsinki.fi/courses/582202" target="_blank">Tietoliikenteen perusteet</a>.</p>


            <h2>HTTP: Selainten ja palvelinten välinen kommunikaatioprotokolla</h2>
	    
            <p>HTTP (<em>HyperText Transfer Protocol</em>) on TCP/IP -protokollapinon sovellustason protokolla, jota web-palvelimet ja selaimet käyttävät kommunikointiin. HTTP-protokolla perustuu asiakas-palvelin malliin, jossa jokaista pyyntöä kohden on yksi vastaus (<em>request-response paradigm</em>). Tämä tarkoittaa sitä, että jokainen pyyntö käsitellään erillisenä kokonaisuutena, eikä saman käyttäjän kahta peräkkäistä pyyntöä yhdistetä automaattisesti toisiinsa.</p>

	    <p>Käytännössä HTTP-asiakasohjelma (jatkossa selain) lähettää HTTP-viestin HTTP-palvelimelle (jatkossa palvelin), joka palauttaa HTTP-vastauksen. Tällä hetkellä eniten käytetty HTTP-protokollan versio on 1.1, joka on määritelty <a href="http://www.w3.org/Protocols/rfc2616/rfc2616.html" target="_blank">RFC 2616</a>-spesifikaatiossa.</p>

            <h3>Asiakas-palvelin malli</h3>

            <p>Asiakas-palvelin -mallissa <em>(Client-Server model)</em> asiakkaat käyttävät palvelimen tarjoamia palveluja. Kommunikointi asiakkaan ja palvelimen välillä tapahtuu usein verkon yli siten, että selain ja palvelin sijaitsevat erillisissä fyysisissä sijainneissa (eri tietokoneilla). Palvelin tarjoaa yhden tai useamman palvelun, joita käyttäjä käyttää selaimen kautta.</p>

            <p>Käytännössä selain näyttää käyttöliittymän ohjelmiston käyttäjälle. Selaimen käyttäjän ei tarvitse tietää, että kaikki käytetty tieto ei ole hänen koneella. Käyttäjän tehdessä toiminnon selain pyytää tarpeen vaatiessa palvelimelta käyttäjän tarpeeseen liittyvää lisätietoa. Tyypillistä mallille on se, että palvelin tarjoaa vain asiakkaan pyytämät tiedot ja verkossa liikkuvan tiedon määrä pidetään vähäisenä.</p>
	    
            <p>Asiakas-palvelin -malli mahdollistaa hajautetut ohjelmistot: selainta käyttävät loppukäyttäjät voivat sijaita eri puolilla maapalloa palvelimen sijaitessa tietyssä paikassa.</p>

		
            <aside class="pohdi">
              <h1>Client&#8211;server model</h1>
		  
              <p>Mene osoitteeseen <a href="https://en.wikipedia.org" target="_blank">https://en.wikipedia.org</a>. Kirjoita sivuston oikeassa ylälaidassa olevaan kenttään "client server model" ja paina Enter-näppäintä. Mitkä seuraavista askeleista tapahtuivat selaimessa, mitkä palvelimella, mitkä muualla?</p>
		  
              <ol>
                <li>Näppäimistön avulla kirjoittamasi osoitetekstin näyttäminen.</li>
                <li>Osoitetta https://en.wikipedia.org vastaavan IP-osoitteen etsiminen.</li>
                <li>Sivun https://en.wikipedia.org näyttäminen.</li>
                <li>https://en.wikipedia.org/wiki/Client&#8211;server_model -sivun näyttäminen</li>
              </ol>
		  
	      <p>Tekstikentästä lähetetään viesti osoitteeseen <a href="https://en.wikipedia.org/w/index.php?search=client+server+model&title=Special%3ASearch&go=Go" target="_blank">https://en.wikipedia.org/w/index.php?search=client+server+model&title=Special%3ASearch&go=Go</a>, mutta päädyt sivulle <a href="https://en.wikipedia.org/wiki/Client&#8211;server_model" target="_blank">https://en.wikipedia.org/wiki/Client&#8211;server_model</a>. Miksi näin tapahtuu?</p>
            </aside>
		
            <p>Haasteena perinteisessä asiakas-palvelin mallissa on se, että palvelin sijaitsee yleensä tietyssä keskitetyssä sijainnissa. Keskitetyillä palveluilla on mahdollisuus ylikuormittua asiakasmäärän kasvaessa. Kapasiteettia rajoittavat muun muassa palvelimen fyysinen kapasiteetti (muisti, prosessorin teho, ..), palvelimeen yhteydessä olevan verkon laatu ja nopeus, sekä tarjotun palvelun tyyppi. Esimerkiksi pyynnöt, jotka johtavat tiedon tallentamiseen, vievät tyypillisesti enemmän resursseja kuin pyynnöt, jotka tarvitsevat vain staattista sisältöä.</p>

		
	    
            <div class="tehtavat">
		  
              <div class="tehtava" id="t-knockknock-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-knockknock">
                      Knock Knock
                    </a>
                  </h1>
                </header>
		
                <div id="t-knockknock" class="collapse">
		  
		  <p>Lähes kaikki sovellusten verkkoliikenne sovellustason protokollasta riippumatta käyttää TCP-yhteyksiä ja -portteja kommunikointiin. TCP-yhteyksiä käytetään Javassa <a href="https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html" target="_blank">Socket</a>- ja <a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html" target="_blank">ServerSocket</a>-luokkien avulla. Lisää aiheesta löytyy <a href="https://docs.oracle.com/javase/tutorial/networking/sockets/" target="_blank">tästä oppaasta</a>.</p>
		  
		  <p>Eräs suosittu viestiprotokolla (eli säännöstö, joka kertoo kuinka kommunikoinnin tulee kulkea) alkaa sanoilla <code>Knock knock!</code>. Toinen osapuoli vastaa tähän <code>Who's there?</code>. Ensimmäinen osapuoli vastaa jotain, esim. <code>Moustache</code>, jonka jälkeen toisen osapuolen tulee vastata <code>Moustache who?</code>. Tähän ensimmäinen osapuoli vastaa viestillä joka päättyy "Bye.".</p>

<pre>
Server: Knock knock!
Client: Who's there?
Server: Moustache
Client: Moustache who?
Server: I Moustache you a question, but I'm shaving it for later! Bye.
</pre>

		  <p>Tehtäväpohjan mukana tulee projekti, on toteutettu valmiiksi palvelinpuolen toiminnallisuus luokassa KnockKnockServer. Palvelinohjelmisto kuuntelee pyyntöä portissa 12345.</p>
		  
		  <p>Tehtävänäsi on toteuttaa valmiiksi toteutettua palvelinkomponenttia varten asiakaspuolen toiminnallisuus, eli sovellus, joka tekee kyselyjä palvelimelle. Asiakaspuolen toiminnallisuutta varten on jo olemassa allaoleva runko, joka tulee tehtäväpohjan pakkauksessa <code>wad.knockknock.client</code> olevassa luokassa <code>KnockKnockClient</code>.</p>

		  <p>Täydennä asiakasohjelmisto annettujen askelten mukaan siten, että sitä voi käyttää kommunikointiin viestiprotokollapalvelimen kanssa.</p>

<pre class="sh_java">
// Luodaan yhteys palvelimelle
Socket socket = new Socket("localhost", port);

Scanner serverMessageScanner = new Scanner(socket.getInputStream());
PrintWriter clientMessageWriter = new PrintWriter(
        socket.getOutputStream(), true);

Scanner userInputScanner = new Scanner(System.in);

// Luetaan viestejä palvelimelta
while (serverMessageScanner.hasNextLine()) {
    // 1. lue viesti palvelimelta
    // 2. tulosta palvelimen viesti standarditulostusvirtaan näkyville

    // 3. jos palvelimen viesti loppuu merkkijonon "Bye.", poistu toistolausekkeesta

    // 4. pyydä käyttäjältä palvelimelle lähetettävää viestiä
    // 5. kirjoita lähetettävä viesti palvelimelle. Huom! Käytä println-metodia.
}
</pre>


		  <p>Kirjoita asiakasohjelmiston lähdekoodi KnockKnockClient-luokan start-metodiin. Kun olet saanut ohjelmiston valmiiksi, suorita ohjelma, jotta voit kokeilla sitä. Tehtäväpohjan mukana on ohjelman käynnistävä main-metodin sisältävä luokka valmiina. Tulostuksen pitäisi olla esimerkiksi seuraavanlainen (käyttäjän syöttämät tekstit on merkitty punaisella):</p>

<pre>
Server: Knock knock!
Type a message to be sent to the server: <font color="red">Who's there?</font>
Server: Lettuce
Type a message to be sent to the server: <font color="red">Lettuce who?</font>
Server: Lettuce in! it's cold out here! Bye.
</pre>

		  <p>Jos asiakasohjelmisto lähettää virheellisiä viestejä, reagoi palvelin siihen seuraavasti:</p>

<pre>
Server: Knock knock!
Type a message to be sent to the server: <font color="red">What?</font>
Server: You are supposed to ask: "Who's there?"
Type a message to be sent to the server: <font color="red">Who's there?</font>
Server: Lettuce
Type a message to be sent to the server: <font color="red">huh</font>
Server: You are supposed to ask: "Lettuce who?"
Type a message to be sent to the server: <font color="red">Lettuce who?</font>
Server: Lettuce in! it's cold out here! Bye.
</pre>

		  <p>Kun olet saanut asiakaspuolen toiminnallisuuden toimimaan, palauta tehtävä TMC:lle.</p>
		  
                </div>
              </div>
	    </div>
	    
	    <p>Edellisessä tehtävässä toteutettu ohjelma voisi aivan yhtä hyvin tehdä kyselyitä web-palvelimelle, mutta tällöin käytettynä viestiprotokollana pitäisi olla HTTP-protokolla. Tutustutaan seuraavaksi tarkemmin HTTP-protokollaan, eli selainten ja palvelinten väliseen kommunikaatioon käytettyyn kommunikaatiotyyliin.</p>


            <h3>HTTP-viestin rakenne: palvelimelle lähetettävä kysely</h3>

            <p>HTTP-protokollan yli lähetettävät viestit ovat tekstimuotoisia. Viestit koostuvat riveistä jotka muodostavat otsakkeen, sekä riveistä jotka muodostavat viestin rungon. Viestin runkoa ei ole pakko olla olemassa -- joskus palautetaan esimerkiksi vain uudelleenohjauskomento. Viestin loppuminen ilmoitetaan kahdella peräkkäisellä rivinvaihdolla.</p>

            <p>Palvelimelle lähetettävän viestin, eli kyselyn, ensimmäisellä rivillä on pyyntötapa, halutun resurssin polku ja HTTP-protokollan versionumero.</p>

<pre>
PYYNTÖTAPA /POLKU_HALUTTUUN_RESURSSIIN HTTP/versio
otsake-1: arvo
otsake-2: arvo

valinnainen viestin runko</pre>

            <p>Pyyntötapa ilmaisee HTTP-protokollassa käytettävän pyynnön tavan (esim. <code>GET</code> tai <code>POST</code>), polku haluttuun resurssiin kertoo haettavan resurssin sijainnin palvelimella (esim. <code>/index.html</code>), ja HTTP-versio kertoo käytettävän version (esim. <code>HTTP/1.0</code>). Alla esimerkki hyvin yksinkertaisesta -- joskin yleisestä -- pyynnöstä. Huomaa että yhteys palvelimeen on jo muodostettu, eli palvelimen osoitetta ei merkitä erikseen.</p>

<pre>
GET /index.html HTTP/1.0

</pre>
	    
            <p>Yksittäisen tietokoneen käyttäminen yhteen web-palvelinohjelmistoon saapuviin pyyntöihin jättää helposti huomattavan osan tietokoneen kapasiteetista käyttämättä. Yleisesti käytössä oleva HTTP/1.1 -protokolla mahdollistaa useamman palvelimen pitämisen samassa IP-osoitteessa virtuaalipalvelintekniikan avulla. Tällöin yksittäiset palvelinkoneet voivat sisältää useita palvelimia. Käytännössä IP-osoitetta kuunteleva kone voi joko itsessään sisältää useita ohjelmistoilla emuloituja palvelimia, tai se voi toimia reitittimenä ja ohjata pyynnön tietylle esimerkiksi yrityksen sisäverkossa sijaitsevalle koneelle.</p>

	    <p>Koska yksittäinen IP-osoite voi sisältää useampia palvelimia, pelkkä polku haluttuun resurssiin ei riitä oikean resurssin löytämiseen: resurssi voisi olla millä tahansa koneeseen liittyvällä virtuaalipalvelimella. HTTP/1.1 -protokollassa on pyynnöissä pakko olla mukana käytetyn palvelimen osoitteen kertova <code>Host</code>-otsake.</p>

<pre>
GET /index.html HTTP/1.1
Host: www.munpalvelin.net

</pre>


	    <h3>Yhteyden muodostaminen palvelimelle Java-maailmassa</h3>
		
	    <p>Java-maailmassa yhteys toiselle koneelle muodostetaan <a href="https://docs.oracle.com/javase/8/docs/api/java/net/Socket.html" target="_blank">Socket</a>-luokan avulla. Kun yhteys on muodostettu, toiselle koneelle lähetettävä viesti kirjoitetaan socketin tarjoamaan <a href="https://docs.oracle.com/javase/8/docs/api/java/io/OutputStream.html" target="_blank">OutputStream</a>-rajapintaan. Tämän jälkeen luetaan vastaus socketin tarjoaman <a href="https://docs.oracle.com/javase/8/docs/api/java/io/InputStream.html" target="_blank">InputStream</a>-rajapinnan kautta.</p>

<pre class="sh_java">
import java.io.PrintWriter;
import java.net.InetAddress;
import java.net.Socket;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        // Connect to the Web server at an address
        String address = "www.helsinki.fi";
        // InetAddress.getByName retrieves an IP for the address
        Socket socket = new Socket(InetAddress.getByName(address), 80);

        // Send a HTTP-request to the server that we are connected to 
        PrintWriter writer = new PrintWriter(socket.getOutputStream());
        writer.println("GET / HTTP/1.1");
        writer.println("Host: " + address);
        writer.println();
        writer.flush();

        // Read the response
        Scanner reader = new Scanner(socket.getInputStream());
        while (reader.hasNextLine()) {
            System.out.println(reader.nextLine());
        }
    }
}
</pre>

	    <p>Yllä oleva ohjelma ottaa yhteyden etsii www.helsinki.fi -osoitteeseen liittyvän palvelimen, ottaa yhteyden palvelimen porttiin 80, ja lähettää palvelimelle seuraavan viestin:</p>

<pre>
GET / HTTP/1.1
Host: www.helsinki.fi

</pre>

	    <p>Tämän jälkeen ohjelma tulostaa palvelimelta saatavan vastauksen.</p>

	    <div class="tehtavat">
              <div class="tehtava" id="t-browser-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-browser">
                      Hello Browser!
                    </a>
                  </h1>
                </header>
		
                <div id="t-browser" class="collapse">
		  
		  <p>Vaikkei kyseessä olekaan selainohjelmointikurssi, on jokaisen hyvä toteuttaa selainohjelmiston ensimmäiset askeleet. Toteuta tehtäväpohjassa olevan <code>HelloBrowser</code>-luokan main-metodiin ohjelma, joka kysyy käyttäjältä sivun osoitetta, tekee syötetyn sivun juureen ("/") pyynnön, ja tulostaa käyttäjälle vastauksen.</p>
		  
		  <p>Alla on esimerkkituloste, missä käyttäjän syöte on annettu punaisella.</p>

<pre>
================
 THE INTERNETS!
================
Where to? <font color="red">www.google.com</font>

==========
 RESPONSE
==========
HTTP/1.1 302 Found
Cache-Control: private
Content-Type: text/html; charset=UTF-8
Location: http://www.google.fi/?gfe_rd=cr&ei=Q5dgVu7zDqOr8wer_4OoCA
Content-Length: 256
Server: GFE/2.0

&lt;HTML&gt;&lt;HEAD&gt;&lt;meta http-equiv="content-type" content="text/html;charset=utf-8"&gt;
&lt;TITLE&gt;302 Moved&lt;/TITLE&gt;&lt;/HEAD&gt;&lt;BODY&gt;
&lt;H1&gt;302 Moved&lt;/H1&gt;
The document has moved
&lt;A HREF="http://www.google.fi/?gfe_rd=cr&amp;ei=Q5dgVu7zDqOr8wer_4OoCA"&gt;here&lt;/A&gt;.
&lt;/BODY&gt;&lt;/HTML&gt;
</pre>

		  <p>Kokeile myös tehdä pyyntö osoitteeseen, jota ei ole olemassa. Minkälaisen virheviestin ohjelmisto tarjoaa?</p>

                </div>
              </div>
	    </div>
	    

            <h3>HTTP-viestin rakenne: palvelimelta saapuva vastaus</h3>

            <p>Palvelimelle tehtyyn pyyntöön saadaan aina jonkinlainen vastaus. Jos tekstimuotoiseen osoitteeseen ei ole liitetty IP-osoitetta DNS-palvelimilla, selain ilmoittaa ettei palvelinta löydy. Jos palvelin löytyy, ja pyyntö saadaan tehtyä palvelimelle asti, tulee palvelimen myös vastata jollain tavalla.</p>

            <p>Palvelimelta saatavan vastauksen sisältö on seuraavanlainen. Ensimmäisellä rivillä HTTP-protokollan versio, viestiin liittyvä statuskoodi, sekä statuskoodin selvennys. Tämän jälkeen on joukko otsakkeita, tyhjä rivi, ja mahdollinen vastausrunko. Vastausrunko ei ole pakollinen.</p>

<pre>
HTTP/versio statuskoodi selvennys
otsake-1: arvo
otsake-2: arvo

valinnainen vastauksen runko
</pre>

            <p>Esimerkiksi:</p>

<pre>
HTTP/1.1 200 OK
Date: Mon, 01 Sep 2014 03:12:45 GMT
Server: Apache/2.2.14 (Ubuntu)
Vary: Accept-Encoding
Content-Length: 973
Connection: close
Content-Type: text/html;charset=UTF-8

.. runko ..</pre>

            <p>Kun palvelin vastaanottaa tiettyyn resurssiin liittyvän pyynnön, tekee se resurssiin liittyviä toimintoja ja palauttaa lopulta vastauksen. Kun selain saa vastauksen, tarkistaa se vastaukseen liittyvän <a href="https://http.cat/" target="_blank">statuskoodin</a> ja siihen liittyvät tiedot -- tyypillinen statuskoodi on <code>200</code> (OK). Tämän jälkeen selain päättelee, mitä vastauksella tehdään, ja esimerkiksi tuottaa vastaukseen liittyvän web-sivun käyttäjälle.</p>

	    <aside class="info">
	      <br/>
	      
	      <h1>HTTP-statuskoodit</h1>

              <p>Statuskoodit (<em>status code</em>) kuvaavat palvelimella tapahtunutta toimintaa kolmella numerolla. Statuskoodien avulla palvelin kertoo mahdollisista ongelmista tai tarvittavista lisätoimenpiteistä. Yleisin statuskoodi on <code>200</code>, joka kertoo kaiken onnistuneen oikein. HTTP/1.1 sisältää viisi kategoriaa vastausviesteihin.</p>

              <ul>
		<li>1**: informaatioviestit (esim 100 "Continue")</li>
		<li>2**: onnistuneet tapahtumat (esim 200 "OK")</li>
		<li>3**: asiakasohjelmistolta tarvitaan lisätoimintoja (esim 301 "Moved Permanently" tai 304 "Not Modified" eli hae välimuistista)</li>
		<li>4**: virhe pyynnössä tai erikoistilanne (esim 401 "Not Authorized" ja 404 "Not Found")</li>
		<li>5**: virhe palvelimella (esim 500 "Internal Server Error")</li>
              </ul>
	    </aside>

            <h3>Palvelimen toiminta Java-maailmassa</h3>
		
	    <p>Palvelimen toiminta muistuttaa huomattavasti aiemmin nähtyä yhteyden muodostamista. Toisin kuin yhteyttä toiseen koneeseen muodostaessa, palvelinta toteutettaessa luodaan <a href="https://docs.oracle.com/javase/8/docs/api/java/net/ServerSocket.html" target="_blank">ServerSocket</a>-olio, joka kuuntelee tiettyä koneessa olevaa porttia. Kun toinen kone ottaa yhteyden palvelimeen, saadaan käyttöön Socket-olio, joka tarjoaa mahdollisuuden lukemiseen ja kirjoittamiseen.</p>

	    <p>Web-palvelin lukee tyypillisesti ensin pyynnön, jonka jälkeen pyyntöön kirjoitetaan vastaus. Alla on esimerkki yksinkertaisen palvelimen toiminnasta -- palvelin on toiminnassa vain yhden pyynnön ajan.</p>

<pre class="sh_java">
import java.io.PrintWriter;
import java.net.ServerSocket;
import java.net.Socket;
import java.util.Scanner;

public class Main {

    public static void main(String[] args) throws Exception {
        // Create a Server Socket that listens to requests on port 8080
        ServerSocket server = new ServerSocket(8080);

        // Wait for a request from a machine, once it apprears, accept it
        Socket socket = server.accept();

        // Read the request
        Scanner requestReader = new Scanner(socket.getInputStream());

        // Write the response
        PrintWriter responseWriter = new PrintWriter(socket.getOutputStream());

        // Close the streams and the socket
        requestReader.close();
        responseWriter.close();
        socket.close();

        // Close the server
        server.close();
    }
}
</pre>

	    <p>Kokeile ylläolevaa ohjelmaa omalla koneellasi. Kuten aiemmissa web-sovelluksissa, voit tässäkin tehdä HTTP-pyynnön porttiin 8080 kirjoittamalla  selaimella osoitteeksi <code>http://localhost:8080</code>. Jos sovelluksen käynnistäminen ei onnistu, tarkista että portti ei ole varattu (et ole sammuttanut jotain aiemmin tekemääsi web-sovellusta).</p>


	    
	    <aside class="info">
	      <br/>
	      <h1>Web-palvelin odottaa pyyntöä selaimelta</h1>
	      
	      <p>ServerSocket-olion accept-metodi on <em>blokkaava</em>. Tämä tarkoittaa sitä, että accept-metodia kutsuttaessa ohjelman suoritus jää odottamaan kunnes palvelimeen otetaan yhteys. Kun yhteys on muodostettu, accept-metodi palauttaa Socket-olion, jota käytetään palvelimen ja yhteyden ottaneen koneen väliseen kommunikointiin.</p>

	      <p>Ohjelmoijan näkökulmasta Socket-oliota -- ja porttia yleisemminkin -- voi ajatella tiedostona. Tiedostoon voi kirjoittaa ja siellä olevaa tietoa voi lukea. Kirjoitettava ja luettava tieto ei kuitenkaan tule tiedostosta, vaan yhteyden toisessa päässä toimivasta ohjelmasta.</p>

	    </aside>
	    
	    <p>Tyypillisesti palvelin halutaan toteuttaa niin, että se kuuntelee ja käsittelee pyyntöjä jatkuvasti. Tämä onnistuu toistolauseen avulla.</p>

<pre class="sh_java">
// Create a Server Socket that listens to requests on port 8080
ServerSocket server = new ServerSocket(8080);

while (true) {
    // Wait for a request from a machine, once it apprears, accept it
    Socket socket = server.accept();

    // Read the request
    Scanner requestReader = new Scanner(socket.getInputStream());

    // Write the response
    PrintWriter responseWriter = new PrintWriter(socket.getOutputStream());

    // Close the streams and the socket
    requestReader.close();
    responseWriter.close();
    socket.close();
}
</pre>

	    <p>Web-palvelimet käsittelevät useampia pyyntöjä lähes samanaikaisesti, sillä palvelinohjelmistot ovat säikeistettyjä. Käytännössä jokainen pyyntö käsitellään erillisessä säikeessä, joka luo pyyntöön vastauksen ja palauttaa sen käyttäjille. Javassa säikeille löytyy oma <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html" target="_blank">Thread</a>-luokka. Emme kuitenkaan tällä kurssilla perehdy säikeiden käyttöön sen tarkemmin -- tätä varten löytyy kurssi <a href="https://www.cs.helsinki.fi/courses/582219" target="_blank">Käyttöjärjestelmät</a>.</p>


	    <aside class="info">
	      <br/>
	      <h1>Tietokoneen portit</h1>

	      <p>Jos kokeilet käynnistää palvelimen koneellasi portissa 80, saatat törmätä virheviestiin. Tähän on useita mahdollisia syitä: (1) koneellasi oleva palomuuri- tai tietoturvaohjelmisto ei salli portin avaamista, (2) portti on jo käytössä (koneellasi oleva ohjelma -- esimerkiksi palvelin -- käyttää porttia 80), tai käyttäjätunnuksellasi ei ole oikeuksia portin avaamiseen.</p>

	      <p>Tietokoneella on käytössä portit 0-65535, joista "normaali" käyttäjä saa tyypillisesti avata vain suurempia kuin 1024 olevia. Lue lisää porteista <a href="https://fi.wikipedia.org/wiki/Portti_(tietoliikenne)" target="_blank">Wikipediasta</a>.</p>
	    </aside>


	    

            <div class="tehtavat">
	      
              <div class="tehtava" id="t-server-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-server">
                      Hello Server!
                    </a>
                  </h1>
                </header>
		
                <div id="t-server" class="collapse">
		  
		  <p>Toteuta web-palvelin, joka kuuntelee pyyntöjä porttiin 8080.</p>
		  
		  <p>Jos pyydetty polku on <code>/quit</code>, tulee palvelin sammuttaa.</p>
		  
		  <p>Muulloin, minkä tahansa pyynnön vastaukseen kirjoitetaan resurssin siirtymisestä kertova (302-alkuinen) HTTP-statuskoodi sekä palvelimen osoite, eli <code>http://localhost:8080</code>.</p>

		  <p>Ota samalla selvää kuinka monta pyyntöä selaimesi tekee palvelimelle, ennen kuin se ymmärtää että jotain on vialla.</p>

		  <img src="img/mooc/ex20-redirectloop.png"/>
		  
                </div>
              </div>
	    </div>
	    

            <aside class="extra">
	      
              <p><strong>Google Dev Tools</strong></p>
		  
              <p>Google Chromen DevTools-apuvälineet löytää Tools-valikosta tai painamalla F12 (Linux). Apuvälineillä voi esimerkiksi tarkastella verkkoliikennettä ja lähetettyjä ja vastaanotettuja paketteja. Valitsemalla työvälineistä Network-välilehden, ja lataamalla sivun uudestaan, näet kaikki sivua varten ladattavat osat sekä kunkin osan lataamiseen kuluneen ajan.</p>

	      <p>Yksittäistä sivua avattaessa tehdään jokaista resurssia (kuva, tyylitiedosto, skripti) varten erillinen pyyntö. Esimerkiksi <a href="http://www.hs.fi" target="_blank">Helsingin sanomien</a> verkkosivua avattaessa tehdään yli 270 erillistä pyyntöä.</p>

	      <img src="img/google-devtools-hs-fi.png"/>

	      
            </aside>
	    
	    
            <h3>HTTP-liikenteen testaaminen telnet-työvälineellä</h3>
	    
            <p>Linux-ympäristöissä on käytössä telnet-työkalu, jota voi käyttää yksinkertaisena asiakasohjelmistona pyyntöjen simulointiin. Telnet-yhteyden tietyn koneen tiettyyn porttiin saa luotua komennolla <code>telnet isäntäkone portti</code>. Esimerkiksi Helsingin sanomien www-palvelimelle saa yhteyden seuraavasti:</p>

<pre>
$ telnet www.hs.fi 80
</pre>

            <p>Tätä seuraa telnetin infoa yhteyden muodostamisesta, jonka jälkeen pääsee kirjoittamaan pyynnön.</p>

<pre>
Trying 158.127.30.40...
Connected to www.hs.fi.
Escape character is '^]'.

</pre>

            <p>Yritetään pyytää HTTP/1.1 -protokollalla juuridokumenttia. Huom! HTTP/1.1 -protokollassa tulee pyyntöön lisätä aina Host-otsake. Jos yhteys katkaistaan ennen kuin olet saanut kirjoitettua viestisi loppuun, ota apuusi tekstieditori ja copy-paste. Muistathan myös että viesti lopetetaan aina kahdella rivinvaihdolla.</p>

<pre>
GET / HTTP/1.1
Host: www.hs.fi

</pre>

            <p>Palvelin palauttaa vastauksen, jossa on statuskoodi ja otsakkeita sekä dokumentin runko.</p>

<pre>
HTTP/1.1 200 OK
X-UA-Compatible: IE=Edge,chrome=1
X-PageCache: true
Content-Type: text/html;charset=UTF-8
Content-Language: en
Content-Length: 485452
Set-Cookie: HSSESSIONID=0E325634FOOH806AC32F62E33F3CF624F3.fe04; Path=/; HttpOnly
Vary: Accept-Encoding
Connection: close

&lt;!DOCTYPE html&gt;
...
</pre>

            <p>Juuripolkua palvelimelta <code>www.hs.fi</code> haettaessa palvelin vastaa "OK" ja palauttaa dokumentin.</p>


	    <p>Jos käytössäsi ei ole Linux-konetta, voit käyttää Telnetiä esimerkiksi <a href="http://www.chiark.greenend.org.uk/~sgtatham/putty/" target="_blank">PuTTY</a>-ohjelmiston avulla. Voit myös tehdä selailua käsin aiemmin toteutetun Java-ohjelman avulla.</p>

	    
            <aside class="pohdi">
              <h1>Kuinka monta hyppyä?</h1>
		  
              <p>Tee telnetillä pyyntö osoitteeseen <code>hs.fi</code> (portti 80) ja selvitä kuinka monta hyppyä tarvitaan siihen, että päästään Helsingin sanomien osoitteessa <code>http://www.hs.fi</code> olevalle etusivulle. Kuinka monta uudelleenohjausta palvelin palauttaa ennenkuin palvelin lopulta kertoo oikean etusivun osoitteen?</p>
	      
              <p>Huom! Jos et ehdi kirjoittamaan komentoa telnet-ikkunaan, voit ensin kirjoittaa sen esimerkiksi tekstieditoriin, ja kopioida sen sieltä telnet-ikkunaan.</p>
		  
<pre>
GET / HTTP/1.1
Host: hs.fi

</pre>

            </aside>


            <h3>HTTP-protokollan pyyntötavat</h3>

            <p>HTTP-protokolla määrittelee kahdeksan erillistä pyyntötapaa (Request method), joista eniten käytettyjä ovat <code>GET</code> ja <code>POST</code>. Pyyntötavat määrittelevät rajoitteita ja suosituksia viestin rakenteeseen ja niiden prosessointiin palvelinpäässä. Esimerkiksi <a href="http://jcp.org/aboutJava/communityprocess/mrel/jsr154/index2.html" target="_blank">Java Servlet API (versio 2.5)</a> sisältää seuraavan suosituksen GET-pyyntotapaan liittyen:</p>

            <p><em>The GET method should be safe, that is, without any side effects for which users are held responsible. For example, most form queries have no side effects. If a client request is intended to change stored data, the request should use some other HTTP method.</em></p>

            <p>Suomeksi yksinkertaistaen: GET-pyynnöt ovat tarkoitettu tiedon hakamiseen. Palvelinpuolen toiminnallisuutta suunniteltaessa tulee siis pyrkiä tilanteeseen, missä <code>GET</code>-tyyppisillä pyynnöillä ei muuteta palvelimella olevaa dataa.</p>

            <h4>Tiedon hakeminen: GET</h4>

            <p>GET-pyyntötapaa käytetään esimerkiksi dokumenttien hakemiseen: kun kirjoitat osoitteen selaimen osoitekenttään ja painat enter, selain tekee GET-pyynnön. GET-pyynnöt eivät tarvitse otsaketietoja HTTP/1.1:n vaatiman Host-otsakkeen lisäksi. Mahdolliset kyselyparametrit lähetetään palvelimelle osana haettavaa osoitetta.</p>

<pre>
GET /sivu.html?porkkana=1 HTTP/1.1
Host: palvelimen-osoite.net

</pre>

	    <p>Spring-sovelluksissa kontrollerimetodi kuuntelee GET-tyyppistä pyyntöä jos <code>@RequestMapping</code>-annotaatiolle on määritelty metodiksi <code>GET</code>: <code>@RequestMapping(value = "polku", method = RequestMethod.GET)</code>.</p>

            <h4>Tiedon lähettäminen: POST</h4>

            <p>Käytännön ero POST- ja GET-kyselyn välillä on se, että POST-tyyppisillä pyynnoillä kyselyparametrit liitetään pyynnön runkoon. Rungon sisältö ja koko määritellään otsakeosiossa. POST-kyselyt mahdollistavat multimedian (kuvat, videot, musiikki, ...) lähettämisen palvelimelle.</p>

<pre>
POST /sivu.html HTTP/1.1
Host: palvelimen-osoite.net
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

porkkana=1
</pre>
	    <p>Spring-sovelluksissa kontrollerimetodi kuuntelee POST-tyyppistä pyyntöä jos <code>@RequestMapping</code>-annotaatiolle on määritelty metodiksi <code>POST</code>: <code>@RequestMapping(value = "polku", method = RequestMethod.POST)</code>.</p>


            <h4>Muita pyyntötyyppejä</h4>

	    <p>Selaimen ja palvelimen välisessä kommunikoinnissa GET- ja POST-tyyppiset pyynnöt ovat eniten käytettyjä. Sivun tai siihen liittyvän osan kuten kuvan hakeminen tapahtuu käytännössä aina GET-tyyppisellä pyynnöllä, ja tiedon lähettäminen esimerkiksi lomakkeen kautta POST-tyyppisellä pyynnöllä. HTTP-protokolla määrittelee muitakin pyyntötyyppejä, joita käytetään palvelinohjelmistojen toteuttamisessa. Oleellisimpia ovat:</p>

	    <ul>
	      <li><em>OPTIONS</em> pyytää tietoja resurssiin liittyvistä vaihtoehdoista (esimerkiksi voidaanko resurssi poistaa, ...)</li>
	      <li><em>DELETE</em> pyytää resurssin poistamista</li>
	      <li><em>HEAD</em> haluaa resurssiin liittyvät otsaketiedot, mutta ei resurssia</li>
	    </ul>


	    <aside class="info">
		  
	      <br/>
	      <h1>HTTP/2</h1>

	      <p>Nykyaikaiset web-sivustot ja palvelinohjelmistot sisältävät tyypillisesti useita erilaisia asioita: kuvia, tyylitiedostoja, musiikkia, videokuvaa ja niin edelleen. Jokainen sivuun liittyvä resurssi tulee hakea erikseen.</p>

	      <p>HTTP-protokollasta julkaistiin toukokuussa 2015 versio <a href="https://en.wikipedia.org/wiki/HTTP/2" target="_blank">HTTP/2</a> (<a href="https://tools.ietf.org/html/rfc7540" target="_blank">RFC 7540</a>). Eräs uudistus protokollassa on palvelimelle jätetty mahdollisuus lähettää pyyntöön vastauksena useampia resursseja saman. Tällöin yhteyden avaamiseen ja sulkemiseen käytetty aika vähenee ja web-sivustojen lataaminen mahdollisesti nopeutuu. HTTP/2 -protokolla sisältää muitakin parannuksia nykytilanteeseen -- suurin osa toiminnallisuudesta toteutetaan kuitenkin palvelinohjelmistoa pyörittävässä palvelimessa, eikä itse palvelinohjelmistossa.</p>
	    </aside>

	    
            <h2>HTML: Yhteinen dokumenttien esityskieli</h2>

            <p>HTML on rakenteellinen kuvauskieli, jolla voidaan esittää linkkejä sisältävää tekstiä sekä tekstin rakennetta. HTML koostuu elementeistä, jotka voivat olla sisäkkäin ja peräkkäin. Elementtejä käytetään ohjeina dokumentin jäsentämiseen ja käyttäjälle näyttämiseen. HTML-dokumenteissa elementit avataan elementin nimen sisältävällä pienempi kuin -merkillä (&lt;) alkavalla ja suurempi kuin -merkkiin (&gt;) loppuvalla merkkijonolla (&lt;elementin_nimi&gt;), ja suljetaan merkkijonolla jossa elementin pienempi kuin -merkin jälkeen on vinoviiva (&lt;/elementin_nimi&gt;).</p>

            <p>HTML-dokumentin rakennetta voi ajatella myös puuna. Juurisolmuna on elementti <code>&lt;html&gt;</code>, jonka lapsina ovat elementit <code>&lt;head&gt;</code> ja <code>&lt;body&gt;</code>.</p>

            <p>Jos elementin sisällä ei ole muita elementtejä tai tekstisolmuja eli tekstiä, voi elementin yleensä avata ja sulkea samalla merkkijonolla: (&lt;elementin_nimi /&gt;).</p>

            <p>HTML:stä on useita erilaisia standardeja, joista viimeisin julkaistu versio on <a href="http://www.w3.org/TR/html5/" target="_blank">HTML5</a>. Versiota <a href="http://www.w3.org/TR/html51/" target="_blank">5.1</a> työstetään tällä hetkellä (viimeisin päivitys 21.6.2016).</p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html lang="fi"&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8" /&gt;
    &lt;title&gt;selainikkunassa näkyvä otsikko&lt;/title&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;p&gt;Tekstiä tekstielementin sisällä, tekstielementti runkoelementin sisällä,
       runkoelementti html-elementin sisällä. Elementin sisältö voidaan asettaa
       useammalle riville.&lt;/p&gt;
  &lt;/body&gt;
&lt;/html&gt;</pre>

            <p>Ylläoleva HTML5-dokumentti sisältää dokumentin tyypin ilmaisevan aloitustägin (<code>&lt;!DOCTYPE html&gt;</code>), dokumentin aloittavan html-elementin (<code>&lt;html&gt;</code>), otsake-elementin ja sivun otsikon (<code>&lt;head&gt;</code>, jonka sisällä <code>&lt;title&gt;</code>), sekä runkoelementin (<code>&lt;body&gt;</code>).</p>

            <p>Elementit voivat sisältää attribuutteja ja attribuuteille voi antaa arvoja. Esimerkiksi ylläolevassa esimerkissä html-elementille on määritelty erillinen attribuutti <em>lang</em>, joka kertoo dokumentissa käytetystä kielestä.  Ylläolevan esimerkin otsakkeessa on myös metaelementti, jota käytetään lisävinkin antamiseen selaimelle: "dokumentissa käytetään UTF-8 merkistöä". Tämä kannattaa olla dokumenteissa aina.</p>

            <p>Nykyaikaiset web-sivut sisältävät paljon muutakin kuin sarjan HTML-elementtejä. Linkitetyt resurssit, kuten kuvat ja tyylitiedostot, ovat oleellisia sivun ulkoasun ja rakenteen luomisessa. Selainpuolella suoritettavat skriptitiedostot, erityisesti Javascript, ovat luoneet huomattavan määrän syvyyttä nykyaikaiseen web-kokemukseen. Tällä kurssilla emme juurikaan syvenny selainpuolen toiminnallisuuteen.</p>

	    <aside class="info">

	      <br/>
	      
	      <h1>Thymeleaf ja HTML</h1>
		  
	      <p>Käytämme kurssilla Thymeleaf-komponenttia dynaamisen sisällön lisäämiseen sivuille. Thymeleaf on erittäin tarkka HTML-dokumentin muodosta, ja pienikin poikkeama voi johtaa virhetilanteeseen. Kannattaakin aina edetä pienin askelein, ja aina muokata ja testata vain yhtä paikkaa kerrallaan. Tällöin virhetilanteessa tyypillisesti tietää mistä kohdasta kannattaa lähteä etsimään virhettä. </p>
	      
	    </aside>


	    <h1>Sovelluksen rakenne ja pyynnön kulku sovelluksessa</h1>

	    <p>Web-sovellusten suunnittelussa noudatetaan useita arkkitehtuurimalleja. Tyypillisimpiä näistä ovat MVC-arkkitehtuuri sekä kerrosarkkitehtuuri, joissa kummassakin perusperiaatteena on vastuiden jako selkeisiin osakokonaisuuksiin.</p>

	    
	    <h2>MVC-arkkitehtuuri</h2>


	    <p>MVC-arkkitehtuurin tavoitteena on käyttöliittymän erottaminen sovelluksen toiminnasta siten, että käyttöliittymät eivät sisällä sovelluksen toiminnan kannalta tärkeää sovelluslogiikkaa. MVC-arkkitehtuurissa ohjelmisto jaetaan kolmeen osaan: malliin (<em>model</em>, tiedon tallennus- ja hakutoiminnallisuus), näkymään (<em>view</em>, käyttöliittymän ulkoasu ja tiedon esitystapa) ja käsittelijään (<em>controller</em>, käyttäjältä saatujen käskyjen käsittely sekä sovelluslogiikka).</p>

	    <p>MVC-mallia on perinteisesti käytetty työpöytäsovelluksiin, missä käsittelijä on voinut olla jatkuvassa yhteydessä näkymään ja malliin. Tällöin käyttäjän yksittäinen toiminta käyttöliittymässä -- esimerkiksi tekstikentän tiedon päivitys -- liittyy tapahtumankäsittelijään, joka ohjaa tiedon malliin liittyvälle ohjelmakoodille, jonka tehtävänä on päivittää sovellukseen liittyvää tietoa tarvittaessa. Tapahtumankäsittelijä mahdollisesti sisältää myös ohjelmakoodia, joka pyytää muunnosta käyttöliittymässä.</p>

	    <p>Web-maailmassa käsittelijän ohjelmakoodia suoritetaan vain kun selain lähettää palvelimelle pyynnön. Ohjelmakoodissa haetaan esimerkiksi tietokannasta tietoa, joka ohjataan näkymän luontiin tarkoitetulle sovelluksen osalle. Kun näkymä on luotu, palautetaan se pyynnön tehneelle selaimelle. Spring-sovelluksissa kontrollereissa näkyvä <code>Model</code> viittaa tietoon, jota käytetään näkymän luomisessa -- se ei kuitenkaan vastaa MVC-mallin model -termiä, joka liittyy kattavammin koko tietokantatoiminnallisuuteen.</p>

	    <div class="image">
              <img src="img/mvc.png"/>
              <div>MVC-mallissa käyttäjän pyyntö ohjautuu kontrollerille, joka sisältää sovelluslogiikkaa. Kontrolleri kutsuu pyynnöstä riippuen mallin toiminnallisuuksia ja hakee sieltä esimerkiksi tietoa. Tämän jälkeen pyyntö ohjataan näkymän luomisesta vastuulle olevalle komponentilla ja näkymä luodaan. Lopulta näkymä palautetaan vastauksena käyttäjän tekemälle pyynnölle.</div>
            </div>
	    
	    <p>MVC-mallista on useita hyötyjä. Käyttöliittymien (näkymien) suunnitelu ja toteutus voidaan eriyttää sovelluslogiikan toteuttamisesta, ja niitä voidaan työstää rinnakkain. Samalla ohjelmakoodi selkenee, sillä eri komponenttien vastuut ovat eriteltyjä -- näkymät eivät sisällä sovelluslogiikkaa, kontrollerin tehtävänä on käsitellä pyynnöt ja ohjata niitä eteenpäin, ja mallin vastuulla on tietoon liittyvät operaatiot. Tämän lisäksi sovellukseen voidaan luoda useampia käyttöliittymiä, joista jokainen käyttää samaa sovelluslogiikkaa, ja pyynnön kulku sovelluksessa selkiytyy.</p>


	    <h2>Kerrosarkkitehtuuri</h2>


	    <p>Kun sovellus jaetaan selkeisiin vastuualueisiin, selkeytyy myös pyynnön kulku sovelluksessa. Kerrosarkkitehtuuria noudattamalla pyritään tilanteeseen, missä sovellus on jaettu itsenäisiin kerroksiin, jotka toimivat vuorovaikutuksessa muiden kerrosten kanssa. Käyttöliittymäkerros sisältää näkymät (esim. Thymeleafin html-sivut) sekä mahdollisen logiikan tiedon näyttämiseen (esim tägit html-sivuilla). Käyttöliittymä näkyy käyttäjän selaimessa, ja käyttäjän selain tekee palvelimelle pyyntöjä käyttöliittymässä tehtyjen klikkausten ja muiden toimintojen pohjalta. Palvelimella toimivan sovelluksen kontrollerikerros ottaa vastaan nämä pyynnöt, ja ohjaa ne eteenpäin sovelluksen sisällä. Tällä kurssilla kerrosarkkitehtuurilla tarkoitetaan yleisesti ottaen seuraavaa jakoa:</p>

            <ul>
              <li>Käyttöliittymäkerros</li>
              <li>Kontrollerikerros</li>
              <li>Sovelluslogiikka ja palvelut</li>
              <li>Tallennuslogiikka (tietokanta-abstraktio ja tietokantapalvelut)</li>
            </ul>

            <p>Kerrosarkkitehtuuria noudattaessa ylempi kerros hyödyntää alemman kerroksen tarjoamia toiminnallisuuksia, mutta alempi kerros ei hyödynnä ylempien kerrosten tarjoamia palveluita. Puhtaassa kerrosarkkitehtuurissa kaikki kerrokset ovat olemassa, ja kutsut eivät ohita kerroksia ylhäältä alaspäin kulkiessaan. Tällä kurssilla noudatamme avointa kerrosarkkitehtuuria, missä kerrosten ohittaminen on sallittua.</p>


	    <div class="image">
              <img src="img/layers.png"/>
              <div>Kerrosarkkitehtuurissa sovelluksen vastuut jaetaan kerroksittain. Näkymäkerros sisältää käyttöliittymät, joista voidaan tehdä pyyntöjä kontrollerille. Kontrolleri käsittelee palveluita, jotka ovat yhteydessä tallennuslogiikkaan. Tiedon tallentamiseen käytettäviä entiteettejä sekä muita luokkia (esim "view objects") käytetään kaikilla kerroksilla.</div>
            </div>


            <h3>Kontrollerikerros</h3>

            <p>Kontrollerien ensisijaisena vastuuna on pyyntöjen kuuntelu, pyyntöjen ohjaaminen sopiville palveluille, sekä tuotetun tiedon ohjaaminen oikealle näkymälle tai näkymän generoivalle komponentille.</p>

            <p>Jotta palveluille ei ohjata epäoleellista dataa, esimerkiksi huonoja arvoja sisältäviä parametreja, on kontrolleritason vastuulla myös pyynnössä olevien parametrien validointi.</p>

	    <p>Kontrollerikerroksen luokissa käytetään annotaatiota <code>@Controller</code>, ja luokkien metodit, jotka vastaanottavat pyyntöjä annotoidaan <code>@RequestMapping</code>-annotaatiolla.</p>


            <h3>Palvelukerros</h3>

            <p>Palvelukerros tarjoaa kontrollerikerrokselle palveluita, joita kontrollerikerros voi käyttää. Palvelut voivat esimerkiksi abstrahoida kolmannen osapuolen tarjoamia komponentteja tai rajapintoja, tai sisältää toiminnallisuutta, jonka toteuttaminen kontrollerissa ei ole järkevää esimerkiksi sovelluksen ylläpidettävyyden kannalta.</p>

	    
            <p>Vaikka palvelukerroksella sijaitsevan toiminnallisuuden voisi sisällyttää kontrollerikerrokseen, kontrollerikerros ennen mittaa muuttuisi yhä epäselkeämmäksi.</p>

	    <p>Palvelukerroksen luokat merkitään annotaatiolla <code>@Service</code> tai <code>@Component</code>. Tämä annotaatio tarkoittaa käytännössä sitä, että sovelluksen käynnistyessä luokka ladataan muistiin ja sen ilmentymä asetetaan olioihin, jotka on merkitty <code>@Autowired</code>-annotaatiolla.</p>

	    <p>Alla olevassa esimerkissä luokka <code>PankkiService</code> tarjoaa pankkipalveluita, ja se on otettu automaattisesti luokan <code>PankkiController</code>-käyttöön.</p>

<pre class="sh_java">
// pakkaus ja importit

@Service
public class PankkiService {

    // käytetyt oliot

    public void siirraRahaa(Long tililta, Long tilille, Double maara) {
        // toteutus
    }
}</pre>

<pre class="sh_java">
// pakkaus ja importit

@Controller
public class PankkiController {

    @Autowired
    private PankkiService pankkiService;

    @RequestMapping(value = "/siirto", method = RequestMethod.POST)
    public String siirraRahaa(@RequestParam Long tililta, 
            @RequestParam Long tilille, @RequestParam Double maara) {
        this.pankkiService.siirraRahaa(tililta, tilille, maara);
        return "redirect:/nakyma";
    }

    // muut toiminnot
}</pre>

	    <p>Yllä <code>PankkiController</code>-luokan vastuut on eritelty selkeästi. Kontrollerin vastuulla on vain pyynnön vastaanotto sekä näkymän luomiseen liittyvä ohjeistus.</p>
	    
            <h3>Tallennuslogiikka</h3>

	    <p>Tallennuslogiikkakerros sisältää tietokannan käyttöön liittyvät oleelliset oliot. Pankki saattaisi tarvita esimerkiksi Tilitapahtumiin liittyvää tallennuslogiikkaa. Täällä olisi esimerkiksi <code>Repository</code>-rajapinnat, jotka perivät rajapinnan <code>JpaRepository</code>.</p>

	    

	    <h3>Tietoa sisältävät oliot</h3>

	    <p>Tiedon esittämiseen liittyvät oliot elävät kerrosarkkitehtuurissa kerrosten sivulla. Esimerkiksi entiteettejä voidaan käsitellä tallennuslogiikkakerroksella (tiedon tallennus), palvelukerroksella (tiedon käsittely), kontrollerikerroksella (tiedon lisääminen Model-olioon) sekä näkymäkerroksella (Model-olion käyttäminen näkymän luomiseen.</p>

	    <p>Sovellusten kehittämisessä näkee välillä myös jaon useampaan erilaiseen tietoa sisältävään oliotyyppiin. Entiteettejä käytetään tietokantatoiminnallisuudessa, mutta välillä näkymien käsittelyyn palautettavat oliot pidetään erillisinä entiteeteistä. Tähän ei ole oikeastaan yhtä oikeaa tapaa: lähestymistapa valitaan tyypillisesti ohjelmistokehitystiimin kesken.</p>



            <aside class="extra">
              <h1>Dependency Injection ja Inversion of Control</h1>
	      
              <p>Jokaisella luokalla on oma selkeä vastuualueensa, ja vastuiden sekoittamista tulee välttää. Inversion of Control ja Dependency Injection ovat suunnitelumalleja, joilla pyritään vähentämään olioiden turhia riippuvuuksia.</p>

              <p>Perinteisissä ohjelmistoissa olioiden luominen on ohjelmoijan vastuulla, mutta ohjelmistokehykset tekevät osan tästä työstä puolestamme.</p>

	      <p>Spring luo käyttöömme luokkia joita tarvitsemme: Kontrollin käännöllä tarkoitetaan ohjelman toiminnan hallinnan vastuun siirtämistä sovelluskehykselle ja ohjelmaa suorittavalle palvelimelle (<em>inversion of control</em>).</p>

	      <p>Spring injektoi <code>@Autowired</code>-annotaatiolla merkittyihin oliomuuttujiin ilmentymät luokista, jotka se lataa käyttöönsä palvelinohjelmiston käynnistyessä (<em>dependency injection</em>). Luokat ladataan annotaatioiden perusteella: jos luokalla on @Controller, @Service, @Component tai @Repository -annotaatio, ladataan se ohjelman käyttöön alussa.</p>

              <p>Lue lisää aiheesta <a href="http://martinfowler.com/articles/injection.html" target="_blank">Martin Fowlerin</a> artikkelista.</p>
            </aside>


	    

            <h1>Tiedon tallentaminen ja hakeminen</h1>

	    <p>Hyvin harva web-sovellus toimii ilman tarvetta tiedon tallentamis- tai hakutoiminnallisuudelle. Tietoa voidaan tallentaa levylle tiedostoihin, tai sitä voidaan tallentaa erilaisiin tietokantaohjelmistoihin. Nämä tietokantaohjelmistot voivat sijaita erillisellä koneella web-sovelluksesta, tai ne voivat itsekin olla web-sovelluksia. Toteutusperiaatteista riippumatta näiden sovellusten ensisijainen tehtävä on varmistaa, ettei käytettävä tieto katoa.</p>
	    
	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Tietokannat, wut?</h1>
	      
	      <p>Jos tietokannat eivät käsitteenä ole tuttuja, ja/tai SQL-kyselyiden kirjoittaminen on ruosteessa, tutustu Helsingin yliopiston kurssin <a href="http://tietokantojen-perusteet.github.io/" target="_blank">tietokantojen perusteet</a> materiaaliin.</p>
	      
	    </aside>
	    

	    <h2>Tietokannan käyttäminen ohjelmallisesti</h2>
	    
	    <p>Käytämme tällä kurssilla <a href="http://www.h2database.com/html/main.html" target="_blank">H2-tietokantamoottoria</a>, joka tarjoaa rajapinan SQL-kyselyiden tekemiseen. H2-tietokantamoottorin saa käyttöön lisäämällä projektin <code>pom.xml</code>-tiedostoon seuraavan riippuvuuden.</p>
	    
<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
    &lt;version&gt;1.4.192&lt;/version&gt;
&lt;/dependency&gt;
</pre>

	    <p>Tietokantaa käyttävä ohjelma sisältää tyypillisesti tietokantayhteyden luomisen, tietokantakyselyn tekemisen tietokannalle, sekä tietokannan palauttamien vastausten läpikäynnin. Javalla edellämainittu näyttää esimerkiksi seuraavalta -- alla oletamme, että käytössä on tietokantataulu "Book", jossa on sarakkeet "id" ja "name".</p>

<pre class="sh_java">
// Open connection to database
Connection connection = DriverManager.getConnection("jdbc:h2:./database", "sa", "");

// Create query and retrieve result set
ResultSet resultSet = connection.createStatement().executeQuery("SELECT * FROM Book");

// Iterate through results
while (resultSet.next()) {
    String id = resultSet.getString("id");
    String name = resultSet.getString("name");

    System.out.println(id + "\t" + name);
}

// Close the resultset and the connection
resultSet.close();
connection.close();
</pre>

	    <p>Oleellisin tässä on luokka <a href="https://docs.oracle.com/javase/8/docs/api/java/sql/ResultSet.html" target="_blank">ResultSet</a>, joka tarjoaa pääsyn rivikohtaisiin tuloksiin. Kurssin <a href="http://tietokantojen-perusteet.github.io/" target="_blank">tietokantojen perusteet</a> oppimateriaali sisältää myös hieman tietoa ohjelmallisista tietokantakyselyistä.</p>

	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Tietokantayhteyden luomisesta</h1>
		  
	      <p>Komento <code>DriverManager.getConnection("jdbc:h2:./database", "sa", "");</code> luo JDBC-yhteyden tietokantaan nimeltä "database". Käyttäjätunnuksena käytetään tunnusta "sa", jonka salasana on "". </p>
	      
	      <p>Jos "database"-nimistä tietokantaa ei ole, luodaan se levyjärjestelmään projektin juureen. Tässä tapauksessa luodaan tiedosto <code>database.mv.db</code> sekä mahdollisesti <code>database.trace.db</code>. Tietokantayhteyden voi luoda myös muistiin ladattavaan tietokantaan, jolloin tietokantaa ei luoda levyjärjestelmään -- tällöin tietokannassa oleva tieto kuitenkin katoaa ohjelman sammutuksen yhteydessä.</p>

	      <p>Tarkempi opas H2-tietokannan tarjoamiin toimintoihin löytyy osoitteesta <a href="http://www.h2database.com/html/tutorial.html" target="_blank">http://www.h2database.com/html/tutorial.html</a>.</p>

	    </aside>
	    
            <p></p>

	    <p>Tietokannalla on tyypillisesti skeema, joka määrittelee tietokantataulujen rakenteen. Rakenteen lisäksi tietokantatauluissa on dataa. Kun tietokantasovellus käynnistetään ensimmäistä kertaa, nämä tyypillisesti ladataan myös käyttöön. H2-tietokantamoottori tarjoaa tätä varten työvälineitä <a href="http://www.h2database.com/javadoc/org/h2/tools/RunScript.html" target="_blank">RunScript</a>-luokassa. Alla olevassa esimerkissä tietokantayhteyden avaamisen jälkeen yritetään lukea tekstitiedostoista <code>database-schema.sql</code> ja <code>database-import.sql</code> niiden sisältö tietokantaan.</p>
	    
	    <p>Tiedosto <code>database-schema.sql</code> sisältää tietokantataulujen määrittelyt, ja tiedosto <code>database-import.sql</code> tietokantaan lisättävää tietoa. Järjestys on oleellinen -- jos tietokantataulujen määrittelyiden lukemisessa tulee virhe, ovat tietokantataulut olemassa, eikä tällöin tietoakaan enää kannata ladata uudestaan.</p>


<pre class="sh_java">
// Open connection to database
Connection connection = DriverManager.getConnection("jdbc:h2:./database", "sa", "");

try {
    // If database has not yet been created, create it
    RunScript.execute(connection, new FileReader("database-schema.sql"));
    RunScript.execute(connection, new FileReader("database-import.sql"));
} catch (Throwable t) {
    System.out.println(t.getMessage());
}
// ...
</pre>


	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellodatabase-ex">
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodatabase">
                      Hello Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodatabase" class="collapse">
		  
		  <p>Käytössäsi on agenttien tietoja sisältävä tietokantataulu, joka on määritelty seuraavasti:</p>
		  
<pre class="sh_sql">
CREATE TABLE Agent (
    id varchar(9) PRIMARY KEY,
    name varchar(200)
);</pre>
		  
		  <p>Kirjoita ohjelma, joka tulostaa kaikki tietokannassa olevat agentit.</p>
		  
                </div>
              </div>
	      
              <div class="tehtava" id="t-helloinsert-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloinsert">
                      Hello Insert
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloinsert" class="collapse">
		  
		  <p>Käytössäsi on edellisessä tehtävässä käytetty agenttien tietoja sisältävä tietokantataulu. Toteuta tässä tehtävässä tietokantaan lisäämistoiminnallisuus. Ohjelman tulee toimia seuraavasti:</p>

<pre>
Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein

Add one:
What id? <font color="red">Riddle</font>
What name? <font color="red">Voldemort</font>

Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein
Riddle	Voldemort
</pre>

		  <p>Seuraavalla käynnistyskerralla agentti Voldemort on tietokannassa heti sovelluksen käynnistyessä.</p>

<pre>
Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein
Riddle	Voldemort

Add one:
What id? <font color="red">Feather</font>
What name? <font color="red">Major Tickle</font>

Agents in database:
Secret	Clank
Gecko	Gex
Robocod	James Pond
Fox	Sasha Nein
Riddle	Voldemort
Feather	Major Tickle
</pre>

                </div>
              </div>
	      
              <div class="tehtava" id="t-hellodao-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodao">
                      Hello Dao
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodao" class="collapse">
		  
		  <p>Edellisissä tietokantatehtävissä tietokantatoiminnallisuus toteutettiin suoraan main-metodiin. Tämä ei ohjelman koon kasvaessa ole toivottua -- toteutetaan tässä rajapinta tietokantatoiminnallisuuden abstrahointiin.</p>
		  
		  <p>Etsi tehtäväpohjasta luokka <code>AgentDao</code> ja toteuta siihen rajapinnan <code>Dao&lt;Agent, String&gt;</code> vaatimien metodien tietokantatoiminnallisuus. Kun ohjelma on toteutettu, luokan HelloDao main-metodi toimii kutakuinkin järkevästi.</p>
		  
                </div>
              </div>
            </div>
	    
	    <aside class="info">
	      <br/>

	      <h1>Web-palvelinohjelmointikurssi?</h1>
	      
	      <p>Edelliset tehtävät antavat vain pienen pintaraapaisun siihen teknologiaan, minkä päälle nykyaikaiset web-sovellukset rakentuvat. Vaikka web-sovelluksia voi toteuttaa ilman suurempaa tietämystä niihin liittyvistä taustateknologioista ja ratkaisuista, omatoiminen syventyminen teemaan kannattaa.</p>
	      
	    </aside>


	    <h2>Oliot ja relaatiotietokannat</h2>

	    <p>Relaatiotietokantojen ja olio-ohjelmoinnin välimaastossa sijaitsee tarve olion muuntamiseen tietokantataulun riviksi ja takaisin. Tähän tehtävään käytetään ORM (<em><a href="https://en.wikipedia.org/wiki/Object-relational_mapping" target="_blank">Object-relational mapping</a></em>) -ohjelmointitekniikkaa, jota varten löytyy merkittävä määrä valmiita työvälineitä sekä kirjastoja.</p>

	    <p>ORM-työvälineet tarjoavat ohjelmistokehittäjälle mm. toiminnallisuutta tietokantataulujen luomiseen määritellyistä luokista, jonka lisäksi ne helpottavat kyselyjen muodostamista ja hallinnoivat luokkien välisiä viittauksia. Tällöin ohjelmoijan vastuulle jää sovellukselle tarpeellisten kyselyiden toteuttaminen vain niiltä osin kun niitä ei tarjota valmiiksi.</p>

            <p>Relaatiotietokantojen käsittelyyn Javalla löytyy joukko ORM-sovelluksia. Oracle/Sun standardoi olioiden tallentamisen relaatiotietokantoihin <a href="http://en.wikipedia.org/wiki/Java_Persistence_API" target="_blank">JPA</a> (<em>Java Persistence API</em>) -standardilla. JPA:n toteuttavat kirjastot (esim. <a href="http://www.hibernate.org/" target="_blank">Hibernate</a>) abstrahoivat relaatiotietokannan ja helpottavat kyselyjen tekemistä suoraan ohjelmakoodista.</p>
	    <p>Koska huomattava osa tietokantatoiminnallisuudesta on hyvin samankaltaista ("tallenna", "lataa", "poista", ...), voidaan perustoiminnallisuus piilottaa käytännössä kokonaan ohjelmoijalta. Tällöin ohjelmoijalle jää tehtäväksi usein vain sopivan rajapintaluokan määrittely. Esimerkiksi aiemmin nähdyn <code>Henkilo</code>-luokan tallentamistoiminnallisuuteen tarvitaan seuraavanlainen rajapinta.</p>

<pre class="sh_java">
// pakkaus ja importit
public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
}</pre>

            <p>Kun rajapintaa käytetään, Spring osaa tuoda sopivan toteutuksen ohjelman käyttöön. Käytössä tulee olla Maven-riippuvuus Spring-projektin Data JPA -kirjastoon.</p>


<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>


            <h2>Luokan määrittely tallennettavaksi</h2>
	    
            <p>JPA-standardin mukaan luokka tulee määritellä <em>entiteetiksi</em>, jotta siitä tehtyjä olioita voi tallentaa JPA:n avulla tietokantaan.</p>

            <p>Jokaisella tietokantaan tallennettavalla luokalla tulee olla annotaatio <code>@Entity</code> sekä <code>@Id</code>-annotaatiolla merkattu attribuutti, joka toimii tietokantataulun ensisijaisena avaimena. JPA:ta käytettäessä <code>id</code>-attribuutti on usein numeerinen (<code>Long</code> tai <code>Integer</code>), mutta merkkijonojen käyttö on yleistymässä. Näiden lisäksi, luokan tulee toteuttaa <code>Serializable</code>-rajapinta.</p>

            <p>Numeeriselle avainattribuutille voidaan lisäksi määritellä annotaatio <code>@GeneratedValue(strategy = GenerationType.AUTO)</code>, joka antaa id-kentän arvojen luomisen vastuun tietokannalle. Tietokantatauluun tallennettava luokka näyttää seuraavalta:</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;

@Entity
public class Henkilo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String nimi;

    // getterit ja setterit</pre>

            <p>Tietokantaan luotavien sarakkeiden ja tietokantataulun nimiä voi muokata annotaatioiden <code>@Column</code> ja <code>@Table</code> avulla.</p>

<pre class="sh_java">
// pakkaus

import java.io.Serializable;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.Table;

@Entity
@Table(name = "Henkilo")
public class Henkilo implements Serializable {

    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    @Column(name = "id")
    private Long id;
    @Column(name = "nimi")
    private String nimi;
    // getterit ja setterit</pre>

            <p>Ylläoleva konfiguraatio määrittelee luokasta <code>Henkilo</code> tietokantataulun nimeltä "Henkilo", jolla on sarakkeet "id" ja "nimi". Sarakkeiden tyypit päätellään muuttujien tyyppien perusteella.</p>

            <p>Spring Data JPA:n <a href="http://docs.spring.io/autorepo/docs/spring-data-jpa/current/api/org/springframework/data/jpa/domain/AbstractPersistable.html" target="_blank">AbstractPersistable</a>-luokkaa käytettäessä ylläolevan luokan määrittely kutistuu hieman. Yläluokka AbstractPersistable määrittelee pääavaimen, jonka lisäksi luokka toteuttaa myös rajapinnan Serializable. </p>

<pre class="sh_java">
// pakkaus ja importit

@Entity
@Table(name = "Henkilo")
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    @Column(name = "nimi")
    private String nimi;
    // getterit ja setterit</pre>

            <p>Jos tietokantataulun ja sarakkeiden eksplisiittisen poistaa, niiden nimet päätellään luokan ja muuttujien nimistä.</p>

<pre class="sh_java">
// pakkaus ja importit

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    // getterit ja setterit</pre>


            <h2>Transaktioiden hallinta</h2>

	    <p>Transaktioiden avulla varmistetaan, että joko kaikki halutut operaatiot suoritetaan, tai yhtäkään niistä ei suoriteta.</p>

            <p>Tietokantatransaktiot määritellään metodi- tai luokkatasolla annotaation <code>@Transactional</code> avulla. Annotaatiolla <code>@Transactional</code> merkittyä metodia suoritettaessa metodin alussa aloitetaan tietokantatransaktio, jossa tehdyt muutokset viedään tietokantaan metodin lopussa. Jos annotaatio <code>@Transactional</code> määritellään luokkatasolla, se koskee jokaista luokan metodia.</p>

	    <p>Alla on kuvattuna tilisiirto, joka on ehkäpä klassisin transaktiota vaativa tietokantaesimerkki. Jos ohjelmakoodin suoritus epäonnistuu (esim. päätyy poikkeukseen) sen jälkeen kun toiselta tililtä on otettu rahaa, mutta toiselle sitä ei vielä ole lisätty, peruuntuu myös rahan ottaminen tililtä. Jos metodille ei olisi määritelty <code>@Transactional</code>-annotaatiota, rahat katoaisivat.</p>

<pre class="sh_java">
@Transactional
public void siirraRahaa(Long tililta, Long tilille, Double paljonko) {
    Tili mista = tiliRepository.findOne(tililta);
    Tili minne = tiliRepository.findOne(tilille);

    mista.setSaldo(mista.getSaldo() - paljonko);
    minne.setSaldo(minne.getSaldo() + paljonko);
}</pre>


            <p>Annotaatiolle <code>@Transactional</code> voidaan määritellä parametri <code>readOnly</code>, jonka avulla määritellään kirjoitetaanko muutokset tietokantaan. Jos parametrin <code>readOnly</code> arvo on <code>true</code>, metodiin liittyvä transaktio perutaan metodin lopussa (rollback). Tällöin metodi ei yksinkertaisesti voi muuttaa tietokannassa olevaa tietoa. </p>

            <p>Rajapinnalla <code>JpaRepository</code> on määriteltynä transaktiot luokkatasolle. Tämä tarkoittaa sitä, että yksittäiset tallennusoperaatiot toimivat myös ilman <code>@Transactional</code>-annotaatiota.</p>

	    <h3>Entiteettien hallinta</h3>

	    <p>Jos metodille on määritelty annotaatio <code>@Transactional</code>, pitää JPA kirjaa tietokannasta ladatuista entiteeteistä ja tarkastelee niihin tapahtuvia muutoksia. Muutokset viedään tietokantaan metodin suorituksen lopussa. Aiempi esimerkkimme siis tekee suorittaa tilisiirrot vaikka tilejä ei erikseen tallennettaisi.</p>

<pre class="sh_java">
@Transactional
public void siirraRahaa(Long tililta, Long tilille, Double paljonko) {
    Tili mista = tiliRepository.findOne(tililta);
    Tili minne = tiliRepository.findOne(tilille);

    mista.setSaldo(mista.getSaldo() - paljonko);
    minne.setSaldo(minne.getSaldo() + paljonko);
}</pre>

	    <p>Jos taas annotaatiota <code>@Transactional</code> ei olisi määritelty, tulisi tilit erikseen tallentaa, jotta niihin tapahtuneet muutokset vietäisiin tietokantaan.</p>


<pre class="sh_java">
public void siirraRahaa(Long tililta, Long tilille, Double paljonko) {
    Tili mista = tiliRepository.findOne(tililta);
    Tili minne = tiliRepository.findOne(tilille);

    mista.setSaldo(mista.getSaldo() - paljonko);
    minne.setSaldo(minne.getSaldo() + paljonko);

    tiliRepository.save(mista);
    tiliRepository.save(minne);
}</pre>



            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-banktransfer">
                      Bank Transfer
                    </a>
                  </h1>
                </header>
                <div id="t-banktransfer" class="collapse">
		  
                  <p>Sovelluksessa on valmiina yksinkertainen sovellus tilien hallintaan ja tilisiirtojen tekemiseen. Sovelluksen tilisiirtotoiminnallisuudessa on kuitenkin vielä jonkin verran viilattavaa.</p>

		  <p>Pohdi minkälaisia korjauksia tilisiirtotoiminnallisuus tarvitsee ja toteuta ne. Kerro myös tehtävän palautuksen yhteydessä tekemäsi korjaukset.</p>

                  <p>Kun olet valmis, lähetä sovellus TMC:lle.</p>
                </div>
              </div>
	    </div>





            <h2>Viitteet tietokantataulujen välillä</h2>

            <p>Luokkien -- tai tietokantataulujen -- väliset viittaukset tapahtuvat kuten normaalistikin, mutta ohjelmoijan tulee lisäksi määritellä osallistumisrajoitteet. Osallistumisrajoitteet -- yksi moneen (<em>one to many</em>), moni yhteen (<em>many to one</em>), moni moneen (<em>many to many</em>) lisätään annotaatioiden avulla. Luodaan esimerkiksi luokka <code>Henkilo</code>, joka voi omistaa joukon esineitä. Kukin esine on vain yhden henkilön omistama -- suhde siis yksi moneen -- annotaatio <code>@OneToMany</code>.</p>

<pre class="sh_java">
@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    @OneToMany
    private List&lt;Esine&gt; esineet;


    // ...
    public List&lt;Esine&gt; getEsineet() {
        if (this.esineet == null) {
            this.esineet = new ArrayList&lt;&gt;();
        }

        return this.esineet;
    }
    // ...
</pre>

            <p>Yllä olevaa esimerkkiä käytettäessä luokalle <code>Esine</code> luodaan tietokantatauluun automaattisesti sarake, johon tallennetaan omistavan <code>Henkilo</code>-olion yksilöivä tunnus. Esinelista luodaan tarvittaessa jos sitä ei ole jo olemassa.</p>
	    

            <p>Moni-moneen yhteys tapahtuu tietokantatauluja suunniteltaessa liitostaulun avulla. JPA:ssa moni-moneen yhteydet määritellään annotaatiolla <code>@ManyToMany</code>. Tällöin yhteys tulee merkitä kummallekin puolelle. Jos henkilö voi omistaa useita esineitä, ja esineellä voi olla useita omistajia, toteutus on seuraavanlainen.</p>

            <pre class="sh_java">
@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    @ManyToMany
    private List&lt;Esine&gt; esineet;
    ...</pre>

                <pre class="sh_java">
@Entity
public class Esine extends AbstractPersistable&lt;Long&gt; {

    private String nimi;
    private Double paino;
    @ManyToMany(mappedBy = "esineet")
    private List&lt;Henkilo&gt; omistajat;</pre>

            <p>Yllä oleva määritelmä luo liitostaulun Esine- ja Henkilo-taulujen välille. Esine-luokassa olevassa @ManyToMany-annotaatiossa oleva parametri <code>mappedBy = "esineet"</code> kertoo että Esine-luokan <code>omistajat</code>-lista saadaan liitostaulusta, ja että se kytketään luokan Henkilo listaan <code>esineet</code>.</p>

	    <aside class="info">
	      <br/>
	      <h1>@OneToMany ja @ManyToMany -annotaatiot</h1>

	      <p>Kun kirjoitat NetBeansissa viitteen entiteettiluokasta toiseen, NetBeans kysyy viittauksen tyyppiä. Tutustu tähän toiminnallisuuteen, sillä se helpottaa annotaatioiden määrittelyä.</p>

	    </aside>




            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-simplebanking">
                      Simple Banking
                    </a>
                  </h1>
                </header>
                <div id="t-simplebanking" class="collapse">
		  
                  <p>Sovelluksessa on toteutettuna entiteetit tilien ja asiakkaiden hallintaan, mutta niiden väliltä puuttuu kytkös. Muokkaa sovellusta siten, että asiakkaalla voi olla monta tiliä, mutta jokaiseen tiliin liittyy tasan yksi asiakas.</p>
		  
		  <p>Tilin lisäämisen tulee kytkeä tili myös asiakkaaseen. Alla olevassa esimerkissä tietokannassa on kaksi asiakasta ja kolme tiliä.</p>
		  
                  <p><img class="browser-img" src="img/2016-mooc/ex24.png"/></p>
		  
                  <p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
                </div>
              </div>
	    </div>


	    <h2>Transaktiot ja viitteiden automaattinen hallinta</h2>

            <p>Haluamme usein tallentaa olion joka viittaa olioon, josta viitataan takaisin.</p>

            <p>Pohditaan tätä kontekstissa, jossa tavoitteena on lisätä uusia Henkilo-olioita olemassaolevan esineen omistajiksi. Esineellä on lista sen omistajista. Yksi ratkaisu on seuraava. </p>

<pre class="sh_java">
@Transactional
public void lisaaOmistaja(Long henkiloId, Long esineId) {
    Esine esine = esineRepository.findOne(esineId);
    Henkilo henkilo = henkiloRepository.findOne(henkiloId);

    henkilo.getEsineet().add(esine);
    esine.getOmistajat().add(henkilo);
}</pre>

            <p>Koska ylläolevassa esimerkissä koodi suoritetaan transaktion sisällä, ladattuihin olioihin tehdyt muutokset viedään tietokantaan transaktion lopussa.</p>

            <h3>Olemassaolevan olion poistaminen</h3>


            <p>Pohditaan seuraavaksi tilannetta, jossa haluaisimme poistaa tietyn henkilön. Ensimmäinen hahmotelma on kutakuinkin seuraavanlainen:</p>

<pre class="sh_java">
@Transactional
public void remove(Long henkiloId) {
    personRepository.delete(henkiloId);
}</pre>

            <p>Yllä ongelmana on kuitenkin se, että esineet eivät kadota viittausta henkilöön. Käytännössä henkilö jää "haamuksi" järjestelmään tai saamme virheen poistoa yrittäessä. Jos haluamme poistaa viittaukset henkilöön, joudumme tekemään sen käsin.</p>

                <pre class="sh_java">
@Transactional
public void remove(Long henkiloId) {
    Henkilo henkilo = personRepository.findOne(henkiloId);
    
    for (Esine esine: henkilo.getEsineet()) {
        esine.getOmistajat().remove(henkilo);
    }

    personRepository.delete(person);
}</pre>

	    <p>Ei kovin nättiä. </p>


            <h2>Omien kyselyiden toteuttaminen</h2>
	    
            <p>Spring Data JPA ei tarjoa kaikkia kyselyitä valmiiksi. Uudet kyselyt, erityisesti attribuuttien perusteella tapahtuvat kyselyt, tulee määritellä erikseen. Laajennetaan aiemmin määriteltyä rajapintaa <code>HenkiloRepository</code> siten, että sillä on metodi <code>List&lt;Henkilo&gt; findByNimi(String nimi)</code> -- eli hae henkilöt, joilla on tietty nimi.</p>


<pre class="sh_java">
// pakkaus

import org.springframework.data.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    List&lt;Henkilo&gt; findByNimi(String nimi);
}</pre>

            <p>Ylläoleva esimerkki on esimerkki kyselystä, johon ei tarvitse erillistä toteutusta. Koska tietokantataululla on valmis sarake nimi, arvaa Spring Data JPA että kysely olisi muotoa <code>SELECT * FROM Henkilo WHERE nimi = :nimi</code> ja luo sen valmiiksi. Lisää Spring Data JPA:n kyselyistä löytyy sen <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.query-creation" target="_blank">dokumentaatiosta</a>.</p>

            <aside class="extra">
	      <br/>
	      
              <h1>Kyselyt Java Persistence Apin kautta</h1>
	      
              <p>Java Persistence APIn kautta tehdyt kyselyt eivät ole natiivia SQL:ää, vaan seuraavat JPQL-määritelmää (Java Persistence Query Language), joka kuitenkin muistuttaa SQL:ää. JPQL-kielestä löytyy lisää tietoa osoitteesta <a href="http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html" target="_blank">http://docs.oracle.com/javaee/6/tutorial/doc/bnbtg.html</a>.</p>

            </aside>


            <p>Tehdään toinen esimerkki, jossa joudumme oikeasti luomaan oman kyselyn. Lisätään rajapinnalle <code>HenkiloRepository</code> metodi <code>findJackBauer</code>, joka suorittaa kyselyn <code>"SELECT h FROM Henkilo h WHERE h.nimi = 'Jack Bauer'"</code>.</p>


<pre class="sh_java">
// pakkaus

import org.springframework.data.jpa.repository.Query;
import org.springframework.data.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    List&lt;Henkilo&gt; findByNimi(String nimi);
    @Query("SELECT h FROM Henkilo h WHERE h.nimi = 'Jack Bauer'")
    Henkilo findJackBauer();
}</pre>

            <p>Käytössämme on nyt myös metodi <code>findJackBauer</code>, joka suorittaa <code>@Query</code>-annotaatiossa määritellyn kyselyn. Tarkempi kuvaus kyselyiden määrittelystä osana rajapintaa löytyy Spring Data JPAn <a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-methods.at-query" target="_blank">dokumentaatiosta</a>.</p>





            <h2>Viitattujen olioiden noutaminen tietokannasta</h2>

            <p>Tietokanta-abstraktioita tarjoavat komponentit kuten Hibernate päättävät mitä tehdään haettavaan olioon liittyville viitteille. Yksi vaihtoehto on hakea viitatut oliot automaattisesti kyselyn yhteydessä ("Eager"), toinen vaihtoehto taas on hakea viitatut oliot vasta kun niitä pyydetään eksplisiittisesti esimerkiksi get-metodin kautta ("Lazy").</p>

            <p>Tyypillisesti one-to-many ja many-to-many -viitteet haetaan vasta niitä tarvittaessa, ja one-to-one ja many-to-one viitteet heti. Oletuskäyttäytymistä voi muuttaa <a href="http://docs.oracle.com/javaee/6/api/javax/persistence/FetchType.html" target="_blank">FetchType</a>-parametrin avulla. Esimerkiksi alla ehdotamme, että <code>asunnot</code>-lista noudetaan heti.</p>

<pre class="sh_java">
// pakkaus

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;

    // oletamme, että Asunto-entiteetti on olemassa
    @OneToMany(fetch=FetchType.EAGER)
    @JoinColumn 
    private List&lt;Asunto&gt; asunnot; 

    // getterit ja setterit
}
</pre>

            <p>Käytännössä tietokannasta tarvittaessa haku toteutetaan muokkaamalla get-metodia siten, että tietokantakysely tapahtuu metodia kutsuttaessa. Staattisesti tyypitetyissä ohjelmointikielissä tämä käytännössä vaatii sitä, että luokkien rakennetta muutetaan joko ajonaikaisesti tai lähdekooditiedostojen kääntövaiheessa -- käyttämämme komponentit tekevät tämän puolestamme.</p>




            <aside class="info">
	      
	      <br/>
	      
              <h1>N+1 Kyselyn ongelma</h1>
	      
              <p>Viitattujen olioiden lataaminen vasta niitä tarvittaessa on yleisesti ottaen hyvä idea, mutta sillä on myös kääntöpuolensa. Pohditaan tilannetta, missä kirjalla voi olla monta kirjoittajaa, ja kirjoittajalla monta kirjaa -- <code>@ManyToMany</code>. Jos haemme tietokannasta listan kirjoja (1 kysely), ja haluamme tulostaa kirjoihin liittyvät kirjoittajat, tehdään jokaisen kirjan kohdalla erillinen kysely kyseisen kirjan kirjoittajille (n kyselyä). Tätä ongelmaa kutsutaan N+1 -kyselyn ongelmaksi.</p>
		  
              <p>Jos kirjoja tarvitaan sekä ilman kirjoittajaa että kirjoittajan kanssa, on FetchType-parametrin asettaminen <code>EAGER</code>-tyyppiseksi yksi vastaus. Tällöin kuitenkin osassa tapauksista haetaan ylimääräistä dataa tietokannasta. Toinen vaihtoehto on luoda erillinen kysely yhdelle vaihtoehdoista, ja lisätä kyselyyn vinkki (<a href="http://docs.spring.io/spring-data/jpa/docs/current/reference/html/#jpa.query-hints" target="_blank">Spring Data JPA, applying query hints</a>) kyselyn toivotusta toiminnallisuudesta.</p>

            </aside>
		

            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-lentokentat">
                      Airports and aircrafts
                    </a>
                  </h1>
                </header>
                <div id="t-lentokentat" class="collapse">
		  
                  <p>Jatkokehitetään tässä tehtävässä sovellusta lentokoneiden ja lentokenttien hallintaan. Projektissa on jo valmiina ohjelmisto, jossa voidaan lisätä ja poistaa lentokoneita. Tavoitteena on lisätä toiminnallisuus lentokoneiden kotikenttien asettamiseksi.</p>
		  
                  <h1>Tallennettavat: <code>Aircraft</code> ja <code>Airport</code>.</h1>
		  
                  <p>Lisää luokkaan <code>Aircraft</code> attribuutti <code>airport</code>, joka kuvaa lentokoneen kotikenttää, ja on tyyppiä <code>Airport</code>. Koska usealla lentokoneella voi olla sama kotikenttä, käytä attribuutille <code>airport</code> annotaatiota <code>@ManyToOne</code>. Lisää attribuutille myös <code>@JoinColumn</code>-annotaatio, jonka avulla kerrotaan että tämä attribuutti viittaa toiseen tauluun. Lisää luokalle myös oleelliset get- ja set-metodit.</p>
		  
                  <p>Lisää seuraavaksi <code>Airport</code>-luokkaan attribuutti <code>aircrafts</code>, joka kuvaa kaikkia koneita, keiden kotikenttä kyseinen kenttä on, ja joka on tyyppiä <code>List&lt;Aircraft&gt;</code>. Koska yhdellä lentokentällä voi olla useita koneita, lisää attribuutille annotaatio <code>@OneToMany</code>. Koska luokan <code>Aircraft</code> attribuutti <code>airport</code> viittaa tähän luokkaan, aseta annotaatioon <code>@OneToMany</code> parametri <code>mappedBy="airport"</code>. Nyt luokka <code>Airport</code> tietää että attribuuttiin <code>aircrafts</code> tulee ladata kaikki <code>Aircraft</code>-oliot, jotka viittaavat juuri tähän kenttään.</p>
		  
                  <p>Lisää lisäksi <code>Airport</code>-luokan <code>@OneToMany</code>-annotaatioon parametri <code>fetch = FetchType.EAGER</code>, jolloin lentokenttään liittyvät lentokoneet haetaan kyselyn yhteydessä.</p>
		  
                  <p>Lisää lopuksi luokalle <code>Airport</code> oleelliset get- ja set-metodit.</p>
		  
		  
                  <h1>Lentokentän asetus lentokoneelle</h1>
		  
                  <p>Lisää sovellukselle toiminnallisuus lentokentän lisäämiseen lentokoneelle. Käyttöliittymä sisältää jo tarvittavan toiminnallisuuden, joten käytännössä sinun tulee toteuttaa luokalle <code>AircraftController</code> metodi <code>String assignAirport</code>. Kun käyttäjä lisää lentokoneelle lentokenttää, käyttöliittymä lähettää POST-tyyppisen kyselyn osoitteeseen <code>/aircrafts/{aircraftId}/airports</code>, missä <code>aircraftId</code> on lentokoneen tietokantatunnus. Pyynnön mukana tulee lisäksi parametri <code>airportId</code>, joka sisältää lentokentän tietokantatunnuksen.</p>
		  
                  <p>Toteuta metodi siten, että haet aluksi pyynnössä saatuja tunnuksia käyttäen lentokoneen ja lentokentän, tämän jälkeen asetat lentokoneelle lentokentän ja lentokentälle lentokoneen, ja lopuksi tallennat haetut oliot.</p>
		  
                  <p>Ohjaa lopuksi pyyntö osoitteeseen <code>/aircrafts</code></p>
		  
                  <p>Kun olet valmis, lähetä sovellus TMC:lle tarkistettavaksi.</p>
                </div>
              </div>
	      
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-elokuvatietokanta">
                      Movie database
                    </a>
                  </h1>
                </header>
                <div id="t-elokuvatietokanta" class="collapse">
		  
                  <p>Tämä on avoin tehtävä jossa saat itse suunnitella huomattavan osan ohjelman sisäisestä rakenteesta. Ainoat määritellyt asiat ohjelmassa ovat käyttöliittymä ja domain-oliot, jotka tulevat tehtäväpohjan mukana. Tehtäväpohjassa on myös valmis konfiguraatio.</p>
		  
                  <p>Tehtävästä on mahdollista saada yhteensä 4 pistettä.</p>
		  
                  <p>Huom! Kannattanee aloittaa näyttelijän lisäämisestä ja poistamisesta. Suunnittele ensin sopiva tietokantaolio, sekä sille sopivat repository-oliot. Jatka tämän jälkeen kontrollerin toteutuksella -- sekä mahdollisesti palvelukerroksen lisäämisellä. Kannattanee hyödyntää valmiiksi tarjotuissa käyttöliittymätiedostoissa olevaa koodia osana tietokantaolioiden attribuuttien määrittelyä.</p>
		  
                  <h1>pisteytys</h1>
		  
                  <ol class="pisteytys">
                    <li>+ 1p: Näyttelijän lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                      <ul>
                        <li><code>GET /actors</code> - näyttelijöiden listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>actors</code>, joka sisältää kaikki näyttelijät ja luo sivun <code>/src/main/resources/templates/actors.html</code> pohjalta näkymän.</li>
			
                        <li><code>POST /actors</code> - parametri <code>name</code>, jossa on lisättävän näyttelijän nimi. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
			
                        <li><code>DELETE /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää poistettavan näyttelijän tunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                      </ul>
                    </li>
		    
                    <p></p>
		    
                    <li>+ 1p: Elokuvan lisääminen ja poistaminen onnistuu. Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                      <ul>
                        <li><code>GET /movies</code> - elokuvien listaus, ei parametreja pyynnössä. Lisää pyyntöön attribuutin <code>movies</code>, joka sisältää kaikki elokuvat ja luo sivun <code>/src/main/resources/templates/movies.html</code> pohjalta näkymän.</li>
			
                        <li><code>POST /movies</code> - elokuvan lisäys, parametrit <code>name</code>, joka sisältää lisättävän elokuvan nimen, ja <code>lengthInMinutes</code>, joka sisältää elokuvan pituuden minuuteissa. Lisäyksen tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>
			
                        <li><code>DELETE /movies/{movieId}</code> - polun parametri <code>movieId</code>, joka sisältää poistettavan elokuvan tietokantatunnuksen. Poiston tulee lopulta ohjata pyyntö osoitteeseen <code>/movies</code>.</li>
                      </ul>
                    </li>
		    
                    <p></p>
		    
                    <li>+ 2p: Näyttelijän voi lisätä elokuvaan (kun näyttelijä tai elokuva poistetaan, tulee myös poistaa viitteet näyttelijästä elokuvaan ja elokuvasta näyttelijään). Käyttöliittymän olettamat osoitteet ja niiden parametrit:<br/>
                      <ul>
			
                        <li><code>GET /actors/{actorId}</code> - polun parametri <code>actorId</code>, joka sisältää näytettävän näyttelijän tietokantatunnuksen. Asettaa pyyntöön sekä attribuutin <code>actor</code> jossa näyttelijä-olio että attribuutin <code>movies</code>, jossa kaikki elokuvat, sekä luo sivun <code>/src/main/resources/templates/actor.html</code> pohjalta näkymän.</li>
			
                        <li><code>POST /actors/{actorId}/movies</code> - polun parametri <code>actorId</code>, joka sisältää kytkettävän näyttelijän tietokantatunnuksen, ja parametri <code>movieId</code>, joka sisältää kytkettävän elokuvan tietokantatunnuksen. Lisäämisen tulee lopulta ohjata pyyntö osoitteeseen <code>/actors</code>.</li>
                      </ul>
                    </li>
                  </ol>
                </div>
              </div>
            </div>
	    
	    

            <h2>Tietokantakyselyn tulosten järjestäminen ja rajoittaminen</h2>

            <p>Tietokantakyselyn tulokset halutaan usein hakea tai järjestää tietyn kriteerin mukaan. Jos tietokantadatan läpikäynti toteutettaisiin osana palvelua, tekisimme oikeastaan juuri sen työn, missä tietokannat loistavat.</p>

            <p>Esimerkiksi alla oleva lisäys tarjoaa metodin henkilöiden etsimiseen, joilla ei ole huonetta (oletamme että Henkilo-luokalla on attribuutti Asunto).</p>

<pre class="sh_java">
public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    List&lt;Henkilo&gt; findByAsuntoIsNull();
}</pre>

            <p>Vastaavasti voisimme hakea esimerkiksi nimen osalla: <code>findByNimiContaining(String osa)</code>.</p>

            <p>Spring Data JPAn rajapinta <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">JpaRepository</a> mahdollistaa muutaman lisäparametrin käyttämisen osassa pyyntöjä. Voimme esimerkiksi käyttää parametria <a href="http://docs.spring.io/spring-data/commons/docs/current/api/org/springframework/data/domain/PageRequest.html" target="_blank">PageRequest</a>, joka tarjoaa apuvälineet sivuttamiseen sekä pyynnön hakutulosten rajoittamiseen. Alla olevalla PageRequest-oliolla haluasimme ensimmäiset 50 hakutulosta attribuutin nimi mukaan käänteisessä järjestyksessä.</p>

<pre class="sh_java">
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "nimi");</pre>

            <p>Voimme muokata metodia <code>findByAsuntoIsNull</code> hyväksymään <code>Pageable</code>-rajapinnan toteuttavan olion parametriksi, jolloin metodi palauttaa <a href="http://docs.spring.io/spring-data/data-commons/docs/1.6.1.RELEASE/api/org/springframework/data/domain/Page.html" target="_blank">Page</a>-luokan ilmentymän.</p>

<pre class="sh_java">
public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {
    Page&lt;Henkilo&gt; findByAsuntoIsNull(Pageable pageable);
}</pre>

            <p>Yhdistämällä kaksi edellistä, voisimme hakea kaikki huoneettomat henkilöt sopivasti järjestettynä:</p>

<pre class="sh_java">
//...
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;
//...

    // tämä palvelussa
    Pageable pageable = new PageRequest(0, 50, Sort.Direction.DESC, "nimi");
    Page&lt;Henkilo&gt; henkiloSivu = henkiloRepository.findByAsuntoIsNull(pageable);
    List&lt;Henkilo&gt; henkilot = henkiloSivu.getContent();
</pre>



            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-viimeisetviestit">
                      Last Messages
                    </a>
                  </h1>
                </header>
                <div id="t-viimeisetviestit" class="collapse">
		  
                  <p>Tehtävässä on käytössä viestien lähetykseen käytettävä sovellus. Muokkaa sovellusta siten, että MessageServicen <code>list</code>-metodi palauttaa aina vain uusimmat 10 viestiä. Käytä tässä hyödyksi yllä nähtyä Pageable-oliota.</p>
		  
                </div>
              </div>
            </div>
	    

	    
	    <h2>Muita tietokantapalveluita</h2>

	    <p>Web-sovelluksissa käytetään tiedon tallentamiseen erilaisia tietokantapalveluita, joista merkittävimpiä ovat relaatiomalliin perustuvat relaatiotietokannat. Tietokantoja on toki myös muunlaisia: muita vaihtoehtoja ovat esimerkiksi NewSQL-tietokannat, jotka yhdistelevät avain-arvo -tietokantojen ja relaatiotietokantojen hyviä puolia, verkkotietokannat, joissa paljon yhteyksiä sisältävän tiedon hakeminen ja tallentaminen on tehokkaampaa, sekä erilaiset verkossa toimivat palvelut kuten <a href="https://www.firebase.com/" target="_blank">Firebase</a>.</p>

	    <p>Tutustutaan seuraavassa tehtävässä pikaisesti <a href="https://www.firebase.com/" target="_blank">Firebase</a>en. Firebase tarjoaa sovelluskehittäjille ilmaisen paikan tiedon tallentamiseen sovelluksen kehitysvaiheessa. Firebasen oleelliset kirjastot saa projektin käyttöön kun lisää <code>pom.xml</code> -tiedostoon seuraavan riippuvuuden.</p>

<pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;com.firebase&lt;/groupId&gt;
    &lt;artifactId&gt;firebase-client-jvm&lt;/artifactId&gt;
    &lt;version&gt;2.5.2&lt;/version&gt;
&lt;/dependency&gt;
</pre>

	    <p>Firebaseen tallennettavat resurssit liittyvät aina tiettyyn osoitteeseen sekä osoitteen alla olevaan polkuun. Tämän osion viimeisessä tehtävässä on valmiiksi toteutettuna luokka, jonka avulla Firebaseen voi tehdä kyselyitä -- hauskaa tutustumista!</p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellofirebase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellofirebase">
                      Hello Firebase
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellofirebase" class="collapse">
		  
		  <p>Tässä tehtävässä on valmiiksi toteutettuna esineiden tallentaminen ja noutaminen Firebase-palvelusta. Tutustu ensin sovelluksen toimintaan ja kokeile tiedon hakemista ja tallentamista. Huomaat myös, että tieto ei katoa, vaikka käynnistät palvelinohjelmiston uudestaan.</p>
		  
		  <p>Toteuta tehtävässä toiminnallisuus esineiden poistamiseen ja muokkaamiseen. Poistamisen tulee poistaa esine Firebase-palvelusta (luokassa FirebaseService on valmis toiminnallisuus tähän) ja muokkaamisen tulee avata uusi sivu, jossa esineen nimeä voi muuttaa. Voit tehdä konkreettisen muokkaustoiminnallisuuden vaikkapa siten, että poistat vanhan esineen muokkauksen yhteydessä ja lisäät uuden esineen vanhaan esineeseen liittyvillä muokatuilla tiedoilla.</p>
		  
		  <p>Kuten muutamassa aiemmassakin tehtävässä, tässä tehtävässä ei ole testejä. Palauttaessasi tehtävän palvelimelle kerrot tehneesi sen valmiiksi. Testit on jätetty tästä pois, jotta voit luoda oman Firebase-palvelun ja käyttää myös sitä.</p>

		  <p>Kun olet saanut tehtävän valmiiksi, tarkastele vielä sovelluksen rakennetta. Huomaat toivottavasti, että vaikka tallennuslogiikka on muuttunut, niin sen perusosat eivät poikkea merkittävästi muista sovelluksistamme.</p>


                </div>
              </div>
            </div>



          </section>
	  <!-- END OSA2 -->

	  <!-- BEGIN OSA3 -->




<!--
	    
	    <h2>Sovelluksen siirtäminen verkkoon</h2>

            <p>Tutustutaan lopuksi sovelluksen siirtämiseen <a href="https://www.heroku.com/" target="_blank">Heroku</a>-palveluun. Heroku on pilvipalvelu, joka tarjoaa rajoitetun (ja ilmaisen) sijoituspaikan vähän resursseja kuluttaville sovelluksille. Opas Herokun käyttöön löytyy osoitteesta <a href="https://devcenter.heroku.com/articles/getting-started-with-java#introduction" target="_blank">https://devcenter.heroku.com/articles/getting-started-with-java#introduction</a>.</p>

	    <p>Tarvitset 
            <p>Kun olet luonut tunnuksen Herokuun, asenna osoitteesta <a href="https://toolbelt.heroku.com/" target="_blank">https://toolbelt.heroku.com/</a> työvälineet sovelluksen Herokuun siirtämiseen. Seuraa myös sivun "Getting started"-ohjetta, ja suorita sen <code>heroku login</code>-osio.</p>

            <p>Mene tämän jälkeen Albumilista-tehtävän kansioon, missä on myös tiedosto <code>pom.xml</code>. Kirjoita kansiossa komento <code>git init</code>, mikä lisää kansioon versionhallintakansion <code>.git</code>.</p>

            <pre>        
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git init
Initialized empty Git repository in <em>polku</em>/W1E08.Albumilista/.git/</pre>

                <p>Kirjoita tämän jälkeen komento <code>heroku create</code>, mikä luo paikan minne sovelluksen voi lähettää.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ heroku create
Creating aqueous-lowlands-6350... done, stack is cedar
http://aqueous-lowlands-6350.herokuapp.com/ | git@heroku.com:aqueous-lowlands-6350.git</pre>

                <p>Komennolla <code>git remote add heroku git@heroku.com:aqueous-lowlands-6350.git</code> lisätään juuri luotu heroku-sijainti projekti käyttöömme. Huomaa, että <code>git@heroku.com:aqueous-lowlands-6350.git</code> on sama kuin komennon <code>heroku create</code> tulostama sijainti.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git remote add heroku git@heroku.com:aqueous-lowlands-6350.git
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$</pre>        

                <p>Nyt voimme lisätä sovelluksen verkkoon. Jos tehtäväkansiossa on target-kansio, poista se tässä välissä. Kirjoita seuraavaksi komento <code>git add .</code>, jonka jälkeen komento <code>git commit -m "initial commit"</code>. Näillä komennoilla lisäät sovelluksen nykyisen version versionhallintaan. Kirjoita tämän jälkeen <code>git push heroku master</code>, mikä lähettää sovelluksen verkkoon.</p>

                <pre>       
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git add .
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git commit -m "initial commit"
[master (root-commit) 2cbc76b] initial commit
 tulostusta...
avihavai@aavikkokettu:<em>polku</em>/W1E08.Albumilista$ git push heroku master
 tulostusta...
-----> Discovering process types
       Procfile declares types -> web

-----> Compressing... done, 135.6MB
-----> Launching... done, v6
       http://aqueous-lowlands-6350.herokuapp.com/ deployed to Heroku
 hieman tulostusta</pre>

                <p>Nyt, voimme käydä tarkistamassa sovelluksen herokun palvelussa. Yllä olevassa esimerkissä sovellus on lisätty osoitteeseen <a href="http://aqueous-lowlands-6350.herokuapp.com/" target="_blank">http://aqueous-lowlands-6350.herokuapp.com/</a>.</p>
-->


                <h3>Ajan tallentaminen</h3>

                <p>Aikaa kuvaavat attribuutit tulee annotoida <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/Temporal.html" target="_blank">@Temporal</a></code>-annotaatiolla, joka määrittelee mikä osa ajasta tallennetaan. Annotaatiolle annetaan parametrina <code><a href="http://docs.oracle.com/javaee/6/api/javax/persistence/TemporalType.html" target="_blank">TemporalType</a></code>-tyyppinen arvo, joka kertoo tarkemman tallennusmuodon. Arvo <code>TemporalType.DATE</code> tallentaa päivämäärän (esim. 2012-09-15), <code>TemporalType.TIME</code> tallentaa kellonajan (esim. 18:00:00), ja arvo <code>TemporalType.TIMESTAMP</code> tallentaa päivän ja ajan (esim. 2012-09-15 18:00:00).</p>

                <p>Annotaatiolla <code>@Temporal</code> merkityn attribuutin tulee olla joko tyyppiä <code>java.util.Date</code> tai tyyppiä <code>java.util.Calendar</code>. Alla on määritelty entiteettiluokka <code>GroceryItem</code>, joka kuvaa elintarviketta. Elintarvikkeella on myös parasta ennen-päivämäärä (bestBefore).</p>

                <pre class="sh_java">
// pakkaus ja importit

@Entity
public class GroceryItem extends AbstractPersistable&lt;Long&gt; {

    private String name;
    @Temporal(TemporalType.DATE)
    private Date bestBefore;

    // getterit ja setterit
}</pre>



	    
            <div class="tehtavat">
              <div class="tehtava" id="t-readinglist-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-readinglist">
                      Reading List
                    </a>
                  </h1>
                </header>
		
                <div id="t-readinglist" class="collapse">
		  
		  <p>Lukulistasovellus tarjoaa käyttäjälle mahdollisuuden lisätä uusia kirjoja lukulistalle, sekä päivittää jo listalla olevien kirjojen lukustatusta. Kukin kirja voi olla tilassa "unread" (lukematon), "reading" (lukemassa) tai "read" (luettu).</p>

		  <p>Kirjan tilan vaihtaminen tapahtuu käyttöliittymässä olevaa nappia painamalla, ja uuden kirjan lisääminen onnistuu alalaidassa olevan lomakkeen avulla.</p>

		  <img src="img/mooc/ex27-list.png" class="naytto"/>

		  <p>Toteuta ohjelman toimintaan tarvittava tietokantatoiminnallisuus sekä oleelliset ReadingList-luokan vaatimat pyyntömäärittelyt. Kannattanee aloittaa tietokantaa käyttävän luokan (esim. BookDao) määrittelyllä -- tietokantaskeema on annettuna tiedostossa <code>database-schema.sql</code>, jonka lisäksi <code>Book</code>-oliosta lienee hyötyä. Käyttöliittymä on projektissa annettu valmiina.</p> 
		  
                </div>
              </div>
            </div>		
	    



	    
	    
	    
            <div class="tehtavat">
              <div class="tehtava" id="t-helloonetomany-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloonetomany">
                      Hello One-to-Many
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloonetomany" class="collapse">
		      
		  <p>Lue <a href="http://tietokantojen-perusteet.github.io/#chapter6-1" target="_blank">tietokantojen perusteiden</a> kurssimateriaalin luku 6.1.</p>
		      
		  <p>Tässä tehtävässä käytössä on kaksi taulua sisältävä tietokanta. Tietokantataulujen määrittely on seuraava:</p>

<pre class="sh_sql">
CREATE TABLE Agency (
    id integer AUTO_INCREMENT PRIMARY KEY,
    name varchar(200)
);

CREATE TABLE Agent (
    id varchar(9) PRIMARY KEY,
    agency_id integer NOT NULL,
    name varchar(200),
    FOREIGN KEY (agency_id) REFERENCES Agency(id)
);
</pre>

		  <p>Jokaisella agentilla on organisaatio (Agency), johon agentti kuuluu.</p>

		  <p>Tällä hetkellä organisaatiolle löytyy AgencyDao-luokka, jonka avulla organisaatiot saa haettua näppärästi tietokannasta. AgentDao-luokan toiminnallisuudesta puuttuu kuitenkin täysin agenttien liittyminen organisaatioihin. Täydennä AgentDao-luokkaa seuraavasti:</p>

		  <ul>
		    <li>Metodi <code>create(Agent agent)</code> tallentaa agentin tietokantaan siten, että agenttiin liittyy myös organisaatio. Voit olettaa, että metodikutsu agent.getAgency() ei palauta <code>null</code>-viitettä.</li>
		    <li>Metodi <code>findOne(String key)</code> etsii tietokannasta agentin avaimen perusteella (id) ja palauttaa sen. Agenttiin tulee olla lisättynä myös organisaatio, johon agentti kuuluu. Palautettavan agentin metodin <code>getAgency</code> tulee siis palauttaa oikea organisaatio.</li>
		    <li>Metodi <code>findAll()</code> palauttaa kaikki agentit. Kuten edellä, myös tässä jokaisella agentilla tulee olla myös oikea organisaatio.</li>
		    <li>Metodi <code>findByAgency(Agency a)</code> palauttaa kaikki agentit, joiden organisaatio on parametrina annettu organisaatio. Agenttien organisaatioiden tulee olla myös tässä oikein merkitty.</li>
		    <li>Metodi <code>delete(String key)</code> poistaa tietokannasta agentin, jonka tunnus on <code>key</code>.</li>
		  </ul>
		  
                </div>
              </div>
            </div>		
	    

            <div class="tehtavat">
              <div class="tehtava" id="t-hellocategories-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellocategories">
                      Hello Categories
                    </a>
                      </h1>
                </header>
		
                <div id="t-hellocategories" class="collapse">
		  
		  <p>Otetaan juuri harjoiteltu yhdestä-moneen -toiminnallisuus käyttöön web-sovelluksessa, missä tarkoituksena on kategorisoida esineitä. Käytössä oleva tietokantaskeema on seuraavanlainen:</p>

<pre class="sh_sql">
CREATE TABLE Category (
    id integer AUTO_INCREMENT PRIMARY KEY,
    name varchar(200)
);

CREATE TABLE Item (
    id integer AUTO_INCREMENT PRIMARY KEY,
    category_id integer NOT NULL,
    name varchar(200),
    FOREIGN KEY (category_id) REFERENCES Category(id)
);
</pre>

		  <p>Tässä tehtävässä tavoitteenasi on toteuttaa esineiden kategorisointiin vaadittava toiminnallisuus -- sovelluksen ulkoasu on seuraavanlainen:</p>

		  <img src="img/mooc/ex29-categories.png" class="naytto"/>
		  
		  <img src="img/mooc/ex29-items.png" class="naytto"/>
		  


		  <p>Ohjelman rajapinnat, eli tässä tapauksessa osoitteet, ovat seuraavat:</p>

		  <ul>
		    <li>GET-pyyntö osoitteeseen <code>/category</code> listaa kaikki tietokannassa olevat kategoriat.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category</code> luo tietokantaan uuden kategorian. Kategorian nimi tulee pyynnön parametrina nimeltä "name". Uudelleenohjaa pyynnön osoitteeseen <code>/category</code>.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category/:id/delete</code> poistaa tunnuksella <code>:id</code> tietokantaan tallennetun kategorian <em>sekä</em> kaikki siihen liittyvät esineet. Uudelleenohjaa pyynnön osoitteeseen <code>/category</code>. Kertaa miten <code>req.param(":id")</code> toimii!</li>
		    
		    <li>GET-pyyntö osoitteeseen <code>/category/:id</code> näyttää <code>:id</code>-tunnuksella merkityn kategorian sekä kaikki siihen liittyvät esineet.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category/:id/item</code> lisää <code>:id</code>-tunnuksella merkittyyn kategoriaan uuden esineen. Esineen nimi tulee pyynnön parametrina nimeltä "name". Uudelleenohjaa pyynnön osoitteeseen <code>/category/:id</code>, missä <code>:id</code> on kategorian tunnus.</li>
		    <li>POST-pyyntö osoitteeseen <code>/category/:id/item/:itemId/delete</code> poistaa <code>:itemId</code>-tunnuksella merkityn esineen tietokannasta. Uudelleenohjaa pyynnön osoitteeseen <code>/category/:id</code>, missä <code>:id</code> on kategorian tunnus.</li>
		  </ul>
			
		  
		  <p>Tutki tehtävässä valmiiksi annettuja komponentteja ennen aloitusta, ja mieti mitkä palat ovat niitä, jotka tarvitset ensiksi. Voi olla hyvä aloittaa vain kategorioiden käsittelystä ja edetä vasta sitten esineiden käsittelyyn kun kategorioihin liittyvä toiminnallisuus on kunnossa.</p>
		  
		  
                </div>
              </div>
            </div>		
	    




	    <p>Web-sovelluksissa käytetään tiedon tallentamiseen tyypillisesti relaatiotietokantoja (esim. <a href="https://www.postgresql.org/" target="_blank">PostgreSQL</a>). Relaatio

 joiden käyttämisen helpottamiseksi  on rakennettu työvälineitä 

helpottamiseksi on rakennettu päälle on rakennettu työvälineitä  että   käytetään paljon relaatiotietokantoja, Nykyäänkin eniten käytetyt tieto




	    <h2>Tyylitiedostot</h2>

		<p>Olet ehkäpä huomannut, että tähän mennessä tekemämme web-sovellukset eivät ole kovin kaunista katsottavaa. Kurssilla pääpaino on palvelinpään toiminnallisuuden toteuttamisessa, joten emme jatkossakaan keskity sivustojen ulkoasuun. Sivujen ulkoasun muokkaaminen on kuitenkin melko suoraviivaista. Verkosta löytyy iso kasa oppaita sivun ulkoasun määrittelyyn -- <a href="http://www.w3schools.com/css/" target="_blank">tässä yksi</a>.</p>

		<p>Käytämme kurssilla muutamassa tehtävässä valmista <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a> -kirjastoa ulkoasun määrittelyyn. Ulkoasun määrittely tapahtuu lisäämällä sivun <code>head</code>-osioon oleelliset kirjastot -- tässä kirjastot haetaan <a href="https://www.bootstrapcdn.com/" target="_blank">https://www.bootstrapcdn.com/</a>-palvelusta, joka tarjoaa kirjastojen ylläpito- ja latauspalvelun.</p>

		<p>Alla on esimerkki HTML-sivusta, jossa Twitter Bootstrap on otettu käyttöön. Sivulla on lisäksi määritelty <code>body</code>-elementin luokaksi (class) "container", mikä tekee sivusta päätelaitteen leveyteen reagoivan. Elementillä <code>table</code> oleva luokka "table" lisää elementtiin tyylittelyn. Erilaisiin Twitter Bootstrapin tyyleihin voi tutustua tarkemmin <a href="http://getbootstrap.com/css/" target="_blank">täällä</a>.</p>

<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Blank&lt;/title&gt;
        &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css"/&gt;
        &lt;link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap-theme.min.css"/&gt;
        &lt;script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/js/bootstrap.min.js"&gt;&lt;/script&gt;
    &lt;/head&gt;

    &lt;body class="container"&gt;

        &lt;table class="table"&gt;
            &lt;tr&gt;
                &lt;th&gt;An&lt;/th&gt;
                &lt;th&gt;important&lt;/th&gt;
                &lt;th&gt;header&lt;/th&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
            &lt;tr&gt;
                &lt;td&gt;More&lt;/td&gt;
                &lt;td&gt;important&lt;/td&gt;
                &lt;td&gt;text&lt;/td&gt;
            &lt;/tr&gt;
        &lt;/table&gt;

    &lt;/body&gt;
&lt;/html&gt;
</pre>

		<p></p>

		<div class="tehtavat">
		  <div class="tehtava" id="t-hellocss">

		    <header>
		      <h1>
                        <a data-toggle="collapse" class="collapsed" href="#t-hellocss">
                          Hello CSS
                        </a>
                      </h1>
                    </header>

                    <div id="t-hellocss" class="collapse">

		      <p>Tässä tehtävässä tavoitteena on lähinnä kokeilla sovelluksessa olevaa sivua ilman tyylitiedostoja sekä tyylitiedostojen kanssa. Käynnistä palvelin ja katso miltä juuripolussa toimiva sovellus näyttää.</p>

		      <p>Sammuta tämän jälkeen palvelin ja muokkaa sovellukseen liittyvää <code>index.html</code>-tiedostoa siten, että poistat kommenttimerkit <code>head</code>-elementissä olevien Twitter Bootstrap -kirjaston linkkien ympäriltä. Käynnistä tämän jälkeen palvelin uudestaan ja katso miltä sivu tämän jälkeen näyttää. Oleellista tässä on se, että sivun ulkoasun muuttamiseen tarvittiin käytännössä vain tyylitiedostojen lisääminen.</p>

		      <p>Tehtävässä ei ole testejä -- voit palauttaa sen kun olet kokeillut ylläolevaa muutosta.</p>

                    </div>
                  </div>
                </div>






                <h1>HTTP-protokolla ja tilattomuus</h1>
		
                <p>HTTP on tilaton protokolla, eli se käsittelee jokaisen pyynnön itsenäisenä muista riippumattomana pyyntönä. HTTP-protokolla ei vaadi, että palvelin pitäisi kirjaa pyynnöistä ja kytkisi pyynnöt tiettyyn käyttäjään. Tämä tarkoittaa sitä, että HTTP ei osaa yhdistää samalta käyttäjältä tulevia pyyntöjä toisiinsa, jolloin jokainen pyyntö käsitellään erillisenä pyyntönä.</p>

                <p>Vaikka HTTP on tilaton protokolla, on asiakkaan tunnistamiseen käytetty pitkään erilaisia kiertotapoja. Klassinen -- mutta erittäin huono -- tapa kiertää HTTP:n tilattomuus on ollut säilyttää GET-muotoisessa osoitteessa parametreja, joiden perusteella asiakas voidaan identifioida palvelinsovelluksessa. Parametrien käyttö osoitteissa ei ole kuitenkaan ongelmatonta: osoitteessa olevia parametreja voi helposti muokata käsin, jolloin palvelinsovelluksesta saattaa löytyä tietoturva-aukkoja tai ei-toivottua käyttäytymistä.</p>

                <aside class="info">

		  <br/>
		  
                  <h1>Case: GET-parametri tunnistautumiseen</h1>
		  
                  <p>Eräässä järjestelmässä verkkokaupan toiminnallisuus oli toteutettu siten, että GET-parametrina säilytettiin numeerista ostoskorin identifioivaa tunnusta. Käyttäjäkohtaisuus oli toteutettu palvelinpuolella siten, että tietyllä GET-parametrilla näytettiin aina tietyn käyttäjän ostoskori. Uusien tuotteiden lisääminen ostoskoriin onnistui helposti, sillä pyynnöissä oli aina mukana ostoskorin tunnistava GET-parametri. Ostoskorit oli valitettavasti identifioitu juoksevalla numerosarjalla. Henkilöllä 1 oli ostoskori 1, henkilöllä 2 ostoskori 2 jne.. Koska kuka tahansa pääsi katsomaan kenen tahansa ostoskoria vain osoitteessa olevaa numeroa vaihtamalla, olivat ostoskorien sisällöt välillä hyvin mielenkiintoisia.</p>
		  
                </aside>
		
                 <p>HTTP-protokollan tilattomuus ei pakota palvelinohjelmistoja tilattomuuteen. Palvelimella tilaa pidetään yllä jollain tietyllä tekniikalla, joka taas ei näy HTTP-protokollaan asti. Yleisin tekniikka tilattomuuden kiertämiseen on evästeiden käyttö.</p>


                <h2>HTTP-protokollan tilattomuuden kiertäminen: evästeet</h2>

                <p>HTTP on tilaton protokolla, eli käyttäjän toimintaa ja tilaa ei pysty pitämään yllä puhtaasti HTTP-yhteyden avulla. Käytännössä suurin osa verkkosovelluksista kuitenkin sisältää käyttäjäkohtaista toiminnallisuutta, jonka toteuttamiseen sovelluksella täytyy olla jonkinlainen tieto käyttäjästä ja käyttäjän tilasta. HTTP/1.1 tarjoaa mahdollisuuden tilallisten verkkosovellusten toteuttamiseen evästeiden (<em>cookies</em>) avulla.</p>

                <p>Asettamalla käyttäjän tekemän pyynnön vastaukseen eväste, tulee käyttäjän jatkossa palauttaa kyseinen eväste aina pyynnön otsaketietoina. Tämä tapahtuu automaattisesti selaimen toimesta. Evästeitä käytetään istuntojen (<em>session</em>) ylläpitämiseen: istuntojen avulla on mahdollista pitää kirjaa käyttäjästä useampien pyyntöjen yli.</p>

                <p>Evästeet toteutetaan otsakkeiden avulla. Kun käyttäjä tekee pyynnön palvelimelle ja palvelimella halutaan asettaa käyttäjälle eväste, palauttaa palvelu vastauksen mukana otsakkeen <code>Set-Cookie</code>, jossa määritellään käyttäjäkohtainen evästetunnus. Set-Cookie voi olla esimerkiksi seuraavan näköinen:</p>

                <pre>
Set-Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg; Max-Age=3600; Domain=".helsinki.fi"
                </pre>

                <p>Ylläoleva palvelimelta lähetetty vastaus ilmoittaa pyytää selainta tallettamaan evästeen. Selaimen tulee jatkossa lisätä eväste <code>SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg</code> jokaiseen <code>helsinki.fi</code>-osoitteeseen. Eväste on voimassa tunnin, eli tunnin kuluttua sen voi poistaa. Tarkempi syntaksi evästeen asettamiselle on seuraava:</p>

                <pre>
Set-Cookie: nimi=arvo [; Comment=kommentti] [; Max-Age=elinaika sekunteina]
                      [; Expires=parasta ennen paiva] [; Path=polku tai polunosa jossa eväste voimassa]
                      [; Domain=palvelimen osoite (URL) tai osoitteen osa jossa eväste voimassa]
                      [; Secure (jos määritelty, eväste lähetetään vain salatun yhteyden kanssa)]
                      [; Version=evästeen versio]
                </pre>

                <p>Evästeet tallennetaan selaimen sisäiseen evästerekisteriin, josta niitä haetaan aina kun käyttäjä tekee kyselyn johonkin osoitteeseen. Evästeet lähetetään palvelimelle jokaisen viestin yhteydessä <code>Cookie</code>-otsakkeessa. </p>

                <pre>
Cookie: SESS57a5819a77579dfb1a1466ccceee22a0=0hr0aa2ogdfgkelogg
                </pre>

                <p>Evästeiden nimet ja arvot ovat yleensä monimutkaisia ja satunnaisesti luotuja niiden yksilöllisyyden takaamiseksi. Samaan osoitteeseen voi liittyä myös useampia evästeitä. Yleisesti ottaen evästeet ovat sekä hyödyllisiä että haitallisia: niiden avulla voidaan luoda yksiöityjä käyttökokemuksia tarjoavia sovelluksia, mutta niitä voidaan käyttää myös käyttäjien seurantaan ympäri verkkoa.</p>

                <aside class="info">

		  <br/>

                  <h1>Kekseliästä</h1>

                  <p>Painamalla F12 tai valitsemalla Tools -> Developer tools, pääset tutkimaan sivun lataamiseen ja sisältöön liittyvää statistiikkaa. Lisäneuvoja löytyy <a href="https://developers.google.com/web/tools/chrome-devtools/" target="_blank">Google Developers</a> -sivustolta.</p>

                  <p>Avaa developer tools, ja mene osoitteeseen <a href="http://www.hs.fi" target="_blank">http://www.hs.fi</a>. Valitsemalla developer toolsien välilehden <code>Resources</code>, löydät valikon erilaisista sivuun liittyvistä resursseista. Avaa <code>Cookies</code> ja valitse vaihtoehto <code>www.hs.fi</code>. Kuinka moni palvelu pitää sinusta kirjaa kun menet Helsingin sanomien sivuille?</p>

                </aside>

		<p>Käyttämämme Spark-kirjasto piilottaa suurehkon osan istuntojen luomiseen liittyvästä työstä.</p>

		<h3>Istunnot ja Spark</h3>

		<p>Spark tarjoaa toiminnallisuuden <a href="http://sparkjava.com/documentation.html#sessions" target="_blank">istuntojen luomiseen ja hallintaan</a> <a href="http://sparkjava.com/documentation.html#request" target="_blank">Request</a>-olion tarjoaman <code>session</code>-metodin avulla. Uuden istunnon luominen sekä vanhan istunnon noutaminen tapahtuu antamalla Request-olion session-metodille parametrina arvo <code>true</code>.</p>

		<p>Session-olio tarjoaa kaksi oleellista metodia. Metodi <code>attribute(String key)</code> palauttaa istuntoon <code>key</code>-tunnuksella tallennetun olion tai arvon, ja metodi <code>attribute(String key, Object value)</code> tallentaa istuntoon <code>key</code>-tunnuksella <code>value</code>-arvon. Alla oleva ohjelmakoodi lisää istuntoon tiedon ensimmäisen pyynnön ajanhetkestä, ja palauttaa sen aina pyynnön yhteydessä.</p>

<pre class="sh_java">
// Session-olio haetaan pakkauksesta spark
import spark.Session;
import java.util.Date;

// ...
get("/", (req, res) -> {
    Session sess = req.session(true);
    
    if (sess.attribute("InitialRequest") == null) {
        sess.attribute("InitialRequest", new Date().toString());
    }
    
    return "First request was made at: " + (String) sess.attribute("InitialRequest");
});
// ...</pre>
 
		<p></p>

		<aside class="info">
		  <br/>
		  <h1>Istuntojen testaaminen selaimella</h1>

		  <p>Istuntojen toiminnallisuuden testaaminen selaimella onnistuu näppärästi selainten tarjoaman anonyymitoiminnallisuuden avulla. Esimerkiksi Chromessa voi valita "New incognito window", mikä avaa käyttöön selainikkunan, missä aiemmin luotuja evästeitä ei lähetetä palvelimelle. Tällöin palvelin luulee, että pyyntö on uusi, ja asettaa vastaukseen uuden evästeen.</p>
		  
		</aside>


                <div class="tehtavat">

                  <div class="tehtava" id="t-hellosession-ex">
		    
                    <header>
                      <h1>
                        <a data-toggle="collapse" class="collapsed" href="#t-hellosession">
                          Hello Session!
                        </a>
                      </h1>
                    </header>
		    
                    <div id="t-hellosession" class="collapse">
		      
		      <p>Toteuta sovellus, joka laskee henkilökohtaisia pyyntöjen määriä. Pyyntöjen määrät tulee tallentaa istuntoon.</p>

		      <p>Kun käyttäjä tekee pyynnön palvelimelle, tulee vastauksen ensimmäiseen pyyntöön olla muotoa "counter: 1". Toiseen pyyntöön vastaus on "counter: 2", kolmanteen "counter: 3" jne. Kun toinen käyttäjä tekee pyynnön, tulee vastauksen olla muotoa "counter: 1". Toiseen pyyntöön vastaus on "counter: 2" jne.</p>
                    </div>
                  </div>
		</div>

		<h3>Pyyntöjen tarkastelu Sparkissa</h3>

		<p>Spark tarjoaa näppärän toiminnallisuuden pyyntöjen tarkasteluun jo ennen kuin ne ohjataan <code>get</code> tai <code>post</code>-metodikutsuilla määriteltyihin metodeihin. Metodilla <code>before</code> voidaan määritellä toiminnallisuutta, joka suoritetaan ennen pyynnön ohjaamista eteenpäin. Esimerkiksi alla oleva ohjelmakoodi tulostaa jokaisen pyynnön yhteydessä osoitteen, johon pyyntö on tehty.</p>

<pre class="sh_java">
before("*", (req, res) -> {
    System.out.println("Request to " + req.url());
});
</pre>

		<p>Suoritus jatkuu <code>before</code>ssa määritetyn koodin suorituksen jälkeen normaalisti, eli pyyntö ohjataan metodiin, joka käsittelee pyynnössä määriteltyä polkua. Pyynnön voi myös <a href="http://sparkjava.com/documentation.html#redirects" target="_blank">uudelleenohjata</a> tai pyynnön suorituksen voi <a href="http://sparkjava.com/documentation.html#halting" target="_blank">keskeyttää</a> tarvittaessa.</p>

                <div class="tehtavat">

                  <div class="tehtava" id="t-helloauth-ex">

                    <header>
                      <h1>
                        <a data-toggle="collapse" class="collapsed" href="#t-helloauth">
                          Hello Auth!
                        </a>
                      </h1>
                    </header>

                    <div id="t-helloauth" class="collapse">

		      <p>Tässä tehtävässä tehtävänäsi on toteuttaa yksinkertainen kirjautumistoiminnallisuus. Tehtäväpohjassa on tarjottuna lomake kirjautumiseen, sekä salainen sivu, joka tulee näyttää käyttäjälle jos kirjautuminen onnistuu.</p>

		      <p>Oikea käyttäjätunnus on <strong><code>user</code></strong> ja oikea salasana on <strong><code>pw</code></strong>.</p>

		      <p>Ohjelman toiminnallisuuden tulee olla seuraava:</p>

		      <ul>
			<li>Kun käyttäjä avaa sovelluksen selaimessa (esim. http://localhost:4567), tulee käyttäjälle näyttää sivu <code>index.html</code>.</li>
			<li>Kun käyttäjä yrittää kirjautua lomakkeen avulla, tulee käyttäjätunnus ja salasana tarkistaa. Jos käyttäjätunnus ja salasana ovat oikein, käyttäjälle luodaan istunto, missä on tieto kirjautumisen onnistumisesta ja käyttäjä ohjataan osoitteeseen <code>/secret/</code>. Jos käyttäjätunnus tai salasana on väärin, tulee käyttäjälle näyttää sivu <code>index.html</code> siten, että käyttäjä näkee virheviestin <code>"Invalid credentials, try again."</code>.</li>
			<li>Kun käyttäjä yrittää avata osoitteen <code>/secret/</code> tulee palvelimen tarkastaa onko käyttäjällä istuntoa, jossa olisi määritelty kirjautumisen onnistuminen. Jos istuntoa ei löydy, tulee käyttäjälle palauttaa statuskoodi <code>401</code> ja viesti <code>"Not allowed"</code>. Jos istunto löytyy, käyttäjälle näytetään sivun <code>secret.html</code> sisältö.</li>
		      </ul>

                    </div>
                  </div>
		</div>

		
                <div class="tehtavat">
                  <div class="tehtava" id="t-shoppingspree-ex">
                    <header>
                      <h1>
                        <a data-toggle="collapse" class="collapsed" href="#t-shoppingspree">
                          Shopping Spree!
                        </a>
                      </h1>
                    </header>
		    
                    <div id="t-shoppingspree" class="collapse">
		
		      <p>Istuntoon voidaan tallentaa myös olioita. Tyypillinen esimerkki tällaisesta on ostoskorin täyttäminen.</p>

		      <p>Tehtäväpohjaan on toteutettu osa ostoskoritoiminnallisuuden vaatimista komponenteista. Tehtävänäsi on:</p>

		      <ul>
			<li>ShoppingSpree-luokan toiminnallisuutta siten, että ostoskori tallennetaan käyttäjäkohtaiseen istuntoon.</li>
			<li>Esineen ostoskoriin lisäämisen toteuttaminen palvelinpäässä -- selainpuolen toiminnallisuus on toteutettu.</li>
			<li>Checkout-linkin tarvitseman toiminnallisuuden toteuttaminen -- käyttäjän tulee siis pystyä menemään checkout-sivulle, jossa näytetään ostoskorin tämän hetkinen sisältö.</li>
		      </ul>

                    </div>
                  </div>
                </div>



            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-rakkausmittari">
                      Rakkausmittari
                    </a>
                  </h1>
                </header>
                <div id="t-rakkausmittari" class="collapse">
		  
                  <p>Tehtävässä hyödynnetään ysärihittiä ja jatkokehitetään sovellusta, jota käytetään kahden henkilön yhteensopivuuden laskemiseen.</p>
		  
                  <p>Lisää ensiksi LoveService-luokalle <code>@Service</code>-annotaatio, ja <em>injektoi</em> se luokkaan <code>LoveController</code>. Toteuta tämän jälkeen kontrolleriluokkaan metodi, joka ottaa POST-tyyppisen pyynnön vastaan, ja luo pyynnössä olevista parametreista <code>Pair</code>-olion.</p>
		  
                  <p>Kun Pair-olio on vastaanotettu, käytä kontrolleriin injektoitua <code>LoveService</code>-oliota yhteensopivuuden laskemiseksi.</p>
		  
                  <p>Lopuksi, ohjaa käyttäjä tekemään GET-pyyntö <code>/loves</code>-osoitteeseen. Lisää <code>RedirectAttributes</code>-luokan avulla seuraavaan pyyntöön yhteensopivuutta kuvaava arvo sekä pyynnön parametreista generoitu <code>Pair</code>-luokka. Kun lisäät edellä mainittuja <code>RedirectAttributes</code>-olioon, käytä yhteensopivuusarvon nimenä merkkijonoa <code>match</code> ja pair-olion nimenä merkkijonoa <code>pair</code>. </p>
		  
                </div>
              </div>
            </div>



            <p>Käytännössä palvelin ja sovelluskehys ottaa vastuuta luokkien hallinnoinnista. Sovelluskehys syöttää riippuvuudet niitä tarvittaessa. Molemmat toiminnallisuudet ovat oleellisia kerrosarkkitehtuurin kerrosten toisistaan erottamisessa.</p>


            <div class="tehtavat">
              <div class="tehtava">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-chat">
                      Chat
                    </a>
                  </h1>
                </header>
                <div id="t-chat" class="collapse">
		  
                  <p>Sovelluksessa on valmis Chat-palvelu, sekä valmis komponentti kolmannen osapuolen chattikaverin käyttämiseen, jota ei kuitenkaan ole vielä liitetty sovellukseen. Tässä kolmannen osapuolen palvelu integroidaan osaksi chat-palvelua.</p>
		  
                  <p>Sovelluksen rakenne on seuraava. Luokka <code>MessageController</code> ottaa vastaan pyyntöjä käyttöliittymältä, ja ohjaa niitä <code>MessageService</code>-palvelulle. MessageService tarjoaa metodit viestien listaamiseen ja uuden viestin tallentamiseen: tallentaminen tapahtuu <code>MessageRepository</code>-rajapintaa käyttämällä.</p>
		  
                  <p>Muokkaa <code>MessageService</code>-luokan tarjoamaa viestin tallennusmetodia siten, että kun käyttäjän kirjoittama viesti on tallennettu, viesti annetaan <code>ChatService</code>-oliolle, jonka palauttama viesti myös tallennetaan. Injektoi <code>ChatService</code>-palvelu <code>MessageService</code>-palveluun. Huom! Aseta injektoidun ChatService-olion nimeksi <code>chatService</code>.</p>
		  
                  <p>Kun sovellus toimii, keskustelun pitäisi näyttää esimerkiksi seuraavanlaiselta:</p>
		  
<pre>
You: hello
Mitsuku: How are you today?
You: good, all peanuts
Mitsuku: Glad to hear it.</pre>
                </div>
              </div>
            </div>






            <div class="tehtavat">
              <div class="tehtava" id="t-epicshop-ex">
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-epicshop">
                      Epic Shop
                    </a>
                  </h1>
                </header>
		
                <div id="t-epicshop" class="collapse">
		  
		  <p>Epic Shop-tehtävässä tavoitteenasi on suunnitella ja toteuttaa verkkokauppa, jossa tulee olla seuraavat toiminnallisuudet:</p>
		  <ul>
		    <li>Kauppias voi lisätä kauppaan ostettavia esineitä. Jokaisella esineellä on nimi ja hinta.</li>
		    <li>Asiakas voi listata kaupan esineet ja lisätä niitä ostoskoriin. Ostoskori tallennetaan sessioon.</li>
		    <li>Asiakas voi tilata ostoskorissa olevat esineet. Kun asiakas tilaa esineet, tulee tilaus kauppiaalle näkyviin. Tilauksessa on listaus esineistä sekä asiakkaan nimi ja osoite.</li>
		    <li>Kauppias voi merkitä tilauksen käsitellyksi.</li>
		  </ul>
		  
		  <p>Kauppiaan toiminnallisuuden tulee olla salasanan takana, mutta asiakas voi käyttää järjestelmää myös ilman salasanaa.</p>
		  
		  
                </div>
              </div>
            </div>		
	    		
 	    

	  <!-- END OSA3 --->


	</article>


<!-- BEGIN FOOTER -->

        <footer>
            <p>
                <a id="license" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Hellas</a> sekä <a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;.
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>

        <script src="js/libs/chartist.min.js"></script>
        <script src="js/libs/visibility.core.js"></script>
        <script src="js/libs/visibility.timers.js"></script>
        <script src="js/libs/visibility.fallback.js"></script>
        <script src="js/js-logger.js"></script>
        <script src="js/verticalfloat.js"></script>
        <script src="js/pheromones.js"></script>
        <script src="js/wepa.js"></script>


    </body>
</html>
<!-- END FOOTER -->
