<!-- BEGIN HEADER -->
<!DOCTYPE html>
<html>
    <head>
        <title>Web-palvelinohjelmointi</title>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <link rel="stylesheet" href="js/libs/syntaxhighlight/css/sh_style.css"/>
	<link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.5/css/bootstrap.min.css">
        <link rel="stylesheet" href="css/chartist.min.css"/>
        <link rel="stylesheet" href="css/wepa.css"/>

        <link rel="stylesheet" href="css/wepa-mooc.css"/>

    </head>
    <body>

        <!-- BEGIN NAV -->
        <header role="navigation">
            <h1>
                <button type="button" data-toggle="collapse" data-target=".bs-navbar-collapse">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>

                <a href="http://www.mooc.fi" class="hidden-in-hy">&#171; mooc.fi</a>

            </h1>
            <nav class="collapse bs-navbar-collapse" role="navigation">
                <ul>
                    <li>
                        <a href="index.html">Yleistä</a>
                    </li>
                    <li>
                        <a href="osa1.html">Osa 1</a>
                    </li>
<!--
                    <li>
                        <a href="#osa2">Osa 2</a>
                    </li>
-->
<!--
                    <li>
                        <a href="#viikko3">Viikko 3</a>
                    </li>
                    <li>
                        <a href="#viikko4">Viikko 4</a>
                    </li>
                    <li>
                        <a href="#viikko5">Viikko 5</a>
                    </li>
                    <li>
                        <a href="#viikko6">Viikko 6</a>
                    </li>
                    <li>
                        <a href="#viikko7">Viikko 7</a>
                    </li>
-->
                </ul>

		<div style="direction: rtl;">
		  <button id="logout" class="btn btn-warning">Kirjaudu ulos</button>
		</div>
            </nav>

        </header>
        <!-- // END NAV -->
        <article>


          <div class="modal fade" id="tmcAuthModal" data-backdrop="static" data-keyboard="false"  tabindex="-1" role="dialog" aria-labelledby="tmcAuthModalLabel" aria-hidden="true">
            <div class="modal-dialog">
              <form class="form-inline"  id="TmcLoginForm" role="form">
		<div class="modal-content">
                  <div class="modal-header">
                    <h4 class="modal-title" id="tmcAuthModalLabel">Kirjoita TMC-tunnuksesi</h4>
                  </div>
                  <div class="modal-body">
                    <p>Pyydämme sinua kirjautumaan TMC-tunnuksillasi materiaaliin. Kirjautumistietoja käytetään oppimateriaalin käytön tutkimukseen.</p>
                    <div id="tmc-account-wrong-alert" class="hidden alert alert-danger">Tarkista TMC-tunnuksesi</div>
                    <div class="form-group">
                      <label class="sr-only" for="exampleInputPassword2">TMC-tunnus</label>
                      <input type="text" name="tmcAccountName" class="form-control" id="inputTmcAccount" placeholder="TMC-tunnus">
                    </div>
                  </div>
                  <div class="modal-footer">
                    <button type="button" id="tmcAccountNOACCOUNT" class="btn btn-default" data-dismiss="modal">En halua tai en tiedä TMC-tunnustani</button>
                    <button type="submit" name="tmcLoginButton" id="tmcAccountOK" class="btn btn-primary">OK</button>
                  </div>
		</div><!-- /.modal-content -->
              </form>
            </div><!-- /.modal-dialog -->
          </div><!-- /.modal -->

	  <!-- BEGIN CONTENT -->

	  <section class="no-toc weeklimit" data-week-id="0">
            <h1>Sisällysluettelo</h1>
	    
            <ul class="nav" id="material-toc"></ul>
	    
            <h1>Tehtävät</h1>
	    
            <ul class="nav nav-pills nav-pills-fixed-width" id="tehtavat-toc"></ul>

	  </section>
          <!-- BEGIN OSA1 -->
          <section class="weeklimit" data-week-id="1">
	    
            <header>
              <h1 id="osa1">Osa 1</h1>
            </header>
	    
            <h1>Web-sovellusten alkeet</h1>
	    
            <p>Web-sovellukset koostuvat selain- ja palvelinpuolesta. Käyttäjän koneella toimii selainohjelmisto (esim. <a href="http://chrome.google.com" target="_blank">Google Chrome</a>), jonka kautta käyttäjä tekee pyyntöjä verkossa sijaitsevalle palvelimelle. Kun palvelin vastaanottaa pyynnön, se käsittelee pyynnön ja rakentaa vastauksen. Vastaus voi sisältää esimerkiksi web-sivun HTML-koodia tai jossain muussa muodossa olevaa tietoa.</p>
	    
            <div class="image">
              <img src="img/pyynto.png"/>
              <div>Web-sovellusten käyttäminen: (1) käyttäjä klikkaa linkkiä, (2) selain tekee pyynnön palvelimelle, (3) palvelin käsittelee pyynnön ja rakentaa vastauksen, (4) selaimen tekemään pyyntöön palautetaan vastaus, (5) vastauksen näyttäminen käyttäjälle -- ei tässä kuvassa.</div>
            </div>
	    
            <p>Selainohjelmointiin ja käyttöliittymäpuoleen keskityttäessä painotetaan rakenteen, ulkoasun ja toiminnallisuuden erottamista toisistaan. Karkeasti voidaan sanoa, että selaimessa näkyvän sivun rakenne määritellään <a href="http://en.wikipedia.org/wiki/HTML" target="_blank">HTML</a>-tiedostoilla, ulkoasu <a href="http://en.wikipedia.org/wiki/CSS" target="_blank">CSS</a>-tiedostoilla ja toiminnallisuus <a href="http://en.wikipedia.org/wiki/JavaScript" target="_blank">JavaScript</a>-tiedostoilla.</p>
	    
            <p>Palvelinpuolen toiminnallisuutta toteutettaessa keskitytään tyypillisesti selainohjelmiston tarvitsevan "APIn" suunnitteluun ja toteutukseen, sivujen muodostamiseen selainohjelmistoa varten, datan tallentamiseen ja käsittelyyn, sekä sellaisten laskentaoperaatioiden toteuttamiseen, joita selainohjelmistossa ei kannata tai voida tehdä.</p>
	    
	    
	    <h2>Ensimmäinen palvelinohjelmisto</h2>
	    
	    <p>Käytämme kurssilla <a href="https://spring.io/" target="_blank">Spring</a> -sovellusperheen <a href="http://projects.spring.io/spring-boot/" target="_blank">Spring Boot</a> -projektia web-sovellusten tekemiseen. Merkittävä osa web-sovellusten rakentamisesta perustuu valmiiden kirjastometodien käyttöön. Niiden avulla määritellään (1) mihin osoitteeseen tulevat pyynnöt käsitellään ja (2) mitä pyynnölle tulee tehdä.</p>
	    
	    <aside class="info">
	      
	      <br/>
	      
	      <h1>Maven</h1>
	      
	      <p>Käytämme tällä kurssilla <a href="https://maven.apache.org/" target="_blank">Maven</a>ia valmiiden kirjastojen noutamiseen sekä projektien hallintaan. Tämän takia projektimme on luotu Maven-projekteina -- uuden Maven-projektin luominen onnistuu NetBeansissa valitsemalla File -&gt; New Project -&gt; Maven -&gt; Java Application.</p>
	      
	      <p>Maven-projektin riippuvuudet määritellään projektiin liittyvässä (Project Files) <code>pom.xml</code>-tiedostossa olevassa <code>dependencies</code>-osiossa.</p>
	      
	    </aside>
	    
	    <p>Spring -sovelluskehystä käyttävien web-sovellusten kehityksessä käytettävät osat saa käyttöön lisäämällä projektiin riippuvuuden Spring Boot -projektiin (<code>spring-boot-starter-parent</code>) sekä web-projektiin (<code>spring-boot-starter-web</code>).</p>

<pre class="sh_xml">
&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.4.0.RC1&lt;/version&gt;
&lt;/parent&gt;
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>

            <aside class="info">

	      <br/>
	      
	      <h1>Release Candidate</h1>

	      <p>Käytämme toistaiseksi Spring Boot -projektin version 1.4. esiversiota. Tehtäväpohjiin on valmiiksi määritelty sijainti, mistä esiversio löytyy. Omia kokeiluja varten tulee projektin <code>pom.xml</code>-tiedostoon lisätä määrittely esiversion löytämiseksi:</p>

<pre class="sh_xml">
&lt;repositories&gt;
    &lt;repository&gt;
        &lt;id&gt;spring-milestones&lt;/id&gt;
        &lt;name&gt;spring-milestones&lt;/name&gt;
        &lt;url&gt;http://repo.spring.io/milestone/&lt;/url&gt;
        &lt;releases&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/releases&gt;
        &lt;snapshots&gt;
            &lt;enabled&gt;true&lt;/enabled&gt;
        &lt;/snapshots&gt;
    &lt;/repository&gt;
&lt;/repositories&gt;
</pre>

	    </aside>

	    <p>Kun riippuvuudet on lisätty projektiin ja projektista pääsee käsiksi Spring-sovelluskehyksen metodeihin ja luokkiin, voimme luoda ensimmäisen palvelinohjelmistomme.</p>

<pre class="sh_java">
package heimaailma;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;
import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@SpringBootApplication
@Controller
public class HeiMaailmaController {

    @RequestMapping("*")
    @ResponseBody
    public String home() {
        return "Hei Maailma!";
    }

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HeiMaailmaController.class, args);
    }
}
</pre>

	    <p>Yllä olevassa esimerkissä luodaan pyyntöjä vastaanottava luokka. Pyyntöjä vastaanottavat luokat merkitään <code>@Controller</code>-annotaatiolla. Tämän perusteella Spring-sovelluskehys tietää, että luokan metodit saattavat käsitellä selaimesta tehtyjä pyyntöjä.</p>

	    <p>Luokalle on määritelty lisäksi metodi <code>home</code>, jolla on kaksi annotaatiota: <code>@RequestMapping</code> ja <code>@ResponseBody</code>. Annotaation <code>@RequestMapping</code> avulla määritellään kuunneltava osoite -- tässä kaikki <code>"*"</code>. Annotaatio <code>@ResponseBody</code> kertoo sovelluskehykselle, että metodin vastaus tulee näyttää vastauksena sellaisenaan.</p>

	    <p>Eriytämme pyyntöjä vastaanottavat luokat ja sovelluksen käynnistämiseen käytettävän luokan jatkossa toisistaan.</p>

<pre class="sh_java">
package heimaailma;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class HeiMaailmaApplication {

    public static void main(String[] args) throws Exception {
        SpringApplication.run(HeiMaailmaApplication.class, args);
    }
}
</pre>

<pre class="sh_java">
package heimaailma;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class HeiMaailmaController {

    @RequestMapping("*")
    @ResponseBody
    public String home() {
        return "Hei Maailma!";
    }
}
</pre>


	    <aside class="info">
	      <br/>
	      <h1>Tehtävien tekeminen</h1>
	      
              <p>Tästä eteenpäin materiaalissa on myös ohjelmointitehtäviä. Tehtävien tekeminen ja palautus tapahtuu NetBeans-ympäristössä Test My Code-liitännäisen avulla. Test My Code lataa tehtäväpohjat sinulle valmiiksi.</p>
	      
	      <p>Oletamme, että olet seurannut kurssin työvälineiden hakemiseen liittyviä ohjeita osoitteessa <a href="http://mooc.fi/courses/general/ohjelmointi/" target="_blank">http://mooc.fi/courses/general/ohjelmointi/</a> ja valinnut kurssiksi <code>2016-wepa</code>.</p>
	      
	      <p>Saat tehtävän auki klikkaamalla sen nimeä.</p>
	      
	    </aside>
	    
            <div class="tehtavat">
	      
              <div class="tehtava" id="t-helloweb-ex">
		
                <header>
                  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloweb">
                      Hello World!
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloweb" class="collapse">
		  
                  <p>Kuten huomattava osa ohjelmointikursseista, tämäkin kurssi alkaa tehtävällä, jossa toteutettava ohjelma kirjoittaa tekstin <code>Hello World!</code>.</p>
		  
                  <p>Toteuta tehtäväpohjan pakkauksessa <code>wad.helloworld</code> olevaan <code>HelloWorldController</code> luokkaan toiminnallisuus, joka kuuntelee kaikkia pyyntöjä. Kun palvelin vastaanottaa pyynnön, tulee palvelimen palauttaa merkkijono "Hello World!".</p>
		  
                  <p><img class="browser-img" src="img/2016-mooc/ex1.png"/></p>
		  
                  <p>Käynnistä palvelin painamalla NetBeansin play-nappia tai suorittamalla <code>HelloWorldApplication</code>-luokan <code>main</code>-metodi. Avaa nettiselain, mene osoitteeseen <a href="http://localhost:8080" target="_blank">http://localhost:8080</a> ja näet selaimessasi tekstin "Hello World!".</p>
		  
                  <p>Palvelin sammutetaan NetBeansissa punaista nappia painamalla -- vain yksi sovellus voi olla kerrallaan päällä samassa osoitteessa. Palauta tehtävä lopuksi Test My Code:n submit-napilla.</p>
                </div>
              </div>
	    </div>
	    
	    
	    <aside class="info">
	      <br/>
	      <h1>Apua! Palvelimeni ei suostu sammumaan!</h1>
	      
	      <p>Palvelimen sammuttaminen tapahtuu NetBeansissa punaista neliötä klikkaamalla, joka sammuttaa suoritettavan ohjelman. Joissakin käyttöjärjestelmissä tämä on kuitenkin bugista, jolloin palvelin tulee sammuttaa komentoriviltä.</p>
	      
	      <p>Saat portissa 8080 käynnissä olevan prosessin tunnuksen tietoon terminaalissa komennolla <code>lsof -i :8080</code>. Etsi komennon palauttamasta tulosteesta prosessin tunnus, jonka jälkeen voit sammuttaa prosessin komennolla <code>kill -9 prosessin-tunnus</code>.</p>
	      
	      <p>Esimerkiksi:</p>
		  
<pre>
> lsof -i :8080
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
>
</pre>

	      <p>Yllä prosessin tunnus (PID) on 9916. Tämän jälkeen prosessi sammutetaan komennolla <code>kill -9 9916</code>.</p>

<pre>
> lsof -i :8080
COMMAND  PID     USER   FD   TYPE             DEVICE SIZE/OFF NODE NAME
java    9916 kayttaja   51u  IPv6 0x65802ef6be5c6f29      0t0  TCP *:tram (LISTEN)
> kill -9 9916
</pre>

	    </aside>


	    <h2>Palvelinohjelmiston polut</h2>

	    <p>Opimme aiemmin, että voimme kuunnella kaikkia palvelinohjelmistoon tulevia pyyntöjä asettamalla <code>@RequestMapping</code>-annotaation parametriksi <code>"*"</code>. Käytännössä tämän parametrin avulla määritellään <em>polku</em>, johon palvelimelle tulevat pyynnöt voidaan ohjata. Tähdellä määritellään, että kaikki pyynnöt päätyvät samalle polulle. Muiden polkujen määrittely on luonnollisesti myös mahdollista.</p>
	    
	    <p>Antamalla poluksi merkkijonon <code>"/salaisuus"</code>, kaikki web-palvelimen osoitteeseen <code>/salaisuus</code> tehtävät pyynnöt ohjautuvat kyseiseen polkuun liitettyyn toiminnallisuuteen. Allaolevassa esimerkissä määritellään polku <code>/salaisuus</code> ja kerrotaan, että polkuun tehtävät pyynnöt palauttavat merkkijonon <code>"Kryptos"</code>.</p>
	    
<pre class="sh_java">
    @RequestMapping("/salaisuus")
    @ResponseBody
    public String home() {
        return "Kryptos";
    }
</pre>

	    <p>Yhteen ohjelmaan voi myös määritellä useampia polkuja sekä niihin liittyviä toiminnallisuuksia. Jokainen polku käsitellään omassa metodissaan. Alla olevassa esimerkissä pyyntöjä vastaanottavaan luokkaan on määritelty kolme erillistä polkua, joista jokainen palauttaa käyttäjälle merkkijonon.</p>

<pre class="sh_java">
package polut;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PolkuController {

    @RequestMapping("/path")
    @ResponseBody
    public String path() {
        return "Polku (path)";
    }

    @RequestMapping("/route")
    @ResponseBody
    public String route() {
        return "Polku (route)";
    }

    @RequestMapping("/trail")
    @ResponseBody
    public String trail() {
        return "Polku (trail)";
    }
}
</pre>
	    <p></p>

	    <div class="tehtavat">
	      
	      <div class="tehtava" id="t-hellopaths">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopaths">
                      Hello Paths
                    </a>
                  </h1>
                </header>
                <div id="t-hellopaths" class="collapse">
		  
                  <p>Toteuta pakkauksessa <code>wad.hellopaths</code> olevaan luokkaan <code>HelloPathsController</code> seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/hello</code> palauttaa käyttäjälle merkkijonon "Hello"</li>
		    <li>Pyyntö polkuun <code>/paths</code> palauttaa käyttäjälle merkkijonon "Paths"</li>
		  </ul>
		  
		  <p>Alla olevassa kuvassa on esimerkki tilanteesta, missä selaimella on tehty pyyntö polkuun <code>/hello</code></p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex2.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    <h2>Pyynnön parametrit</h2>
	    
	    <p>Pyynnöissä voi lähettää palvelimelle tietoa. Tutustutaan ensin tapaan, missä pyynnön parametrit lisätään osaksi haettavaa osoitetta. Esimerkiksi pyynnössä <code>http://localhost:8080/salaisuus?onko=nauris</code> on parametri nimeltä <code>onko</code>, jonka arvoksi on määritelty arvo <code>nauris</code>.</p>
	    
	    <p>Parametrien lisääminen pyyntöön tapahtuu lisäämällä osoitteen perään kysymysmerkki, jota seuraa parametrin nimi, yhtäsuuruusmerkki ja parametrille annettava arvo. Pyynnössä tuleviin parametreihin pääsee käsiksi <code><a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/RequestParam.html" target="_blank">@RequestParam</a></code>-annotaation avulla.</p>

	    <p>Allaolevassa esimerkissä on luotu palvelinohjelma, jonka tehtävänä on tervehtiä kaikkia pyynnön tekijöitä. Ohjelma käsittelee polkuun <code>/hei</code> tulevia pyyntöjä ja palauttaa niihin vastauksena tervehdyksen. Tervehdykseen liitetään pyynnössä tulevan <code>nimi</code>-nimisen parametrin arvo.</p>

<pre class="sh_java">
package parametrit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class TervehtijaController {

    @RequestMapping("/hei")
    @ResponseBody
    public String tervehdi(@RequestParam String nimi) {
        return "Hei " + nimi + ", mitä kuuluu?";
    }
}
</pre>

	    <p>Nyt esimerkiksi osoitteeseen <code>http://localhost:8080/hei?nimi=Ada</code> tehtävä pyyntö saa vastaukseksi merkkijonon <code>Hei Ada, mitä kuuluu?</code>.</p>


	    <p>Jos parametreja on useampia, erotellaan ne toisistaan &amp;-merkillä. Seuraavassa esimerkissä pyynnössä on kolme parametria, <code>eka</code>, <code>toka</code> ja <code>kolmas</code>, joiden arvot ovat <code>1</code>, <code>2</code> ja <code>3</code> vastaavasti.</p>
	    
<pre>
http://localhost:8080/salaisuus?eka=1&amp;toka=2&amp;kolmas=3
</pre>

	    <p>Kaikki pyynnössä olevat parametrit saa pyyntöä käsittelevät metodin käyttöön samalla <code>@RequestParam</code>-annotaatiolla. Allaolevassa esimerkissä kaikki pyynnön parametrit asetetaan <code>Map</code>-tietorakenteeseen, jonka jälkeen kaikki pyynnön arvojen avaimet palautetaan kysyjälle.</p>

<pre class="sh_java">
package parametrit;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

@Controller
public class PyyntoParametrienNimetController {

    @RequestMapping("/nimet")
    @ResponseBody
    public String nimet(@RequestParam Map&lt;String, String&gt; parametrit) {
        return parametrit.keySet().toString();
    }
}
</pre>


	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellorequestparams">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellorequestparams">
                      Hello Request Params
                    </a>
                  </h1>
                </header>
                <div id="t-hellorequestparams" class="collapse">
		  
                  <p>Toteuta pakkauksessa <code>wad.hellorequestparams</code> olevaan luokkaan <code>HelloRequestParamsController</code> seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/hello</code> palauttaa käyttäjälle merkkijonon "Hello ", johon on liitetty <code>param</code>-nimisen parametrin sisältämä arvo.</li>
		    <li>Pyyntö polkuun <code>/params</code> palauttaa käyttäjälle kaikkien pyynnön mukana tulevien parametrien nimet ja arvot.</li>
		  </ul>
		  
		  <p>Alla olevassa kuvassa on esimerkki tilanteesta, missä selaimella on tehty pyyntö polkuun <code>/params?hello=world&amp;it=works</code></p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex3.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-calculator">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-calculator">
                      Calculator
                    </a>
                  </h1>
                </header>
                <div id="t-calculator" class="collapse">
		  
		  <p>Toteuta tässä tehtävässä pakkauksessa <code>wad.calculator</code> sijaitsevaan <code>CalculatorController</code>-luokkaan seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö polkuun <code>/add</code> laskee parametrien <code>first</code> ja <code>second</code> arvot yhteen ja palauttaa vastauksen käyttäjälle. Huomaa että arvot ovat numeroita, ja ne tulee myös käsitellä numeroina.</li>
		    
		    <li>Pyyntö polkuun <code>/multiply</code> kertoo parametrien <code>first</code> ja <code>second</code> arvot ja palauttaa vastauksen käyttäjälle.</li>
		    
		    <li>Pyyntö polkuun <code>/sum</code> laskee <em>kaikkien</em> parametrien arvot yhteen ja palauttaa vastauksen käyttäjälle.</li>
		  </ul>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun pyyntö tehdään <code>/sum</code>-polkuun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex4.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
            <h2>Näkymät ja data</h2>
	    

            <p>Tähän asti luomamme sovellukset ovat vastaanottaneet tiettyyn polkuun tulevan pyynnön ja palauttaneet käyttäjälle merkkijonomuodossa olevaa tietoa. Tämä ei kuitenkaan ole ainoa palvelinohjelmistojen toimintatyyppi, vaan palvelin voi myös luoda käyttäjälle näkymän, jonka selain lopulta näyttää käyttäjälle. Näkymät luodaan tyypillisesti HTML-kielellä siten, että HTML-kielen sekaan on upotettu komentoja, joiden perusteella näkymään lisätään palvelimen tuottamaa tietoa.</p>
	    
            <p>Tällä kurssilla käyttämämme apuväline näkymän luomiseen on <a href="http://www.thymeleaf.org/" target="_blank">Thymeleaf</a>, joka tarjoaa välineitä datan lisäämiseen HTML-sivuille. Käytännössä näkymiä luodessa luodaan ensin HTML-sivut, jonka jälkeen sivuille lisätään komentoja Thymeleafin käsiteltäväksi.</p>
	    
            <p>Thymeleaf-sivut ("templatet") sijaitsevat tällä kurssilla projektin kansiossa <code>src/main/resources/templates</code> tai sen alla olevissa kansioissa. NetBeansissa kansio löytyy kun klikataan "Other Sources"-kansiota.</p>

	    <aside class="info">
	      <br/>
	      
	      <h1>Thymeleafin käyttöönotto</h1>
	      
              <p>Thymeleafin käyttöönotto vaatii <code>pom.xml</code>-tiedostossa olevien riippuvuuksien muokkaamista. Web-sovellusten perustoiminnallisuus saatiin käyttöön lisäämällä <code>org.springframework.boot</code>-ryhmän komponentti <code>spring-boot-starter-web</code> pom.xml-tiedoston dependencies-osioon. Kun vaihdamme riippuvuuden muotoon <code>spring-boot-starter-thymeleaf</code>, pääsemme käyttämään Thymeleafia.</p>
	      
              <pre class="sh_xml">
&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</pre>

	      <p>Jos edellämainittu riippuvuus ei ole aiemmin ladattuna koneelle, tulee se myös hakea. Tämä onnistuu joko kirjoittamalla komentorivillä projektin juuressa komento <code>mvn dependency:resolve</code> tai valitsemalle NetBeansissa projektiin liittyvä kansio <em>Dependencies</em> oikealla hiirennapilla ja painamalla <em>Download Declared Dependencies</em>.</p>
	      
	      <p>Thymeleaf vaatii myös, että jokaisen HTML-sivun <code>html</code>-elementin määrittelyssä tulee olla seuraavat määrittelyt.</p>

              <pre class="sh_xml">
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;</pre>
	    </aside>

	    
	    <p>Allaolevassa esimerkissä luodaan juuripolkua <code>/</code> kuunteleva sovellus. Kun sovellukseen tehdään pyyntö, palautetaan HTML-sivu, jonka Thymeleaf käsittelee. Thymeleaf päättelee palautettavan sivun metodin palauttaman merkkijonon perusteella. Alla metodi palauttaa merkkijonon <code>"index"</code>, jolloin Thymeleaf etsii kansiosta <code>src/main/resources/templates/</code> sivua <code>index.html</code>. Kun sivu löytyy, Thymeleaf käsittelee sen ja palauttaa sen käyttäjälle. Palaamme tarkemmin tähän käsittelyyn myöhemmin.</p>


<pre class="sh_java">
package thymeleaf;

import org.springframework.stereotype.Controller;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ThymeleafController {

    @RequestMapping("/")
    public String home() {
        return "index";
    }
}
</pre>

	    <p>Huomaa, että pyyntöjä käsittelevällä metodilla ei enää ole annotaatiota <code>@ResponseBody</code>. Emme siis enää halua, että metodin palauttama arvo näytetään suoraan käyttäjälle, vaan haluamme, että käyttäjälle näytetään merkkijonon ilmaisema näkymä. Näkymä luodaan Thymeleafin avulla.</p>


	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellothymeleaf">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellothymeleaf">
                      Hello Thymeleaf
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellothymeleaf" class="collapse">
		  
		  <p>Toteuta tässä tehtävässä pakkauksessa <code>wad.hellothymeleaf</code> sijaitsevaan <code>HelloThymeleafController</code>-luokkaan seuraava toiminnallisuus:</p>
		  
		  <ul>
		    <li>Pyyntö juuripolkuun <code>/</code> palauttaa käyttäjälle Thymeleafin avulla kansiossa <code>src/main/resources/templates/</code> olevan <code>index.html</code>-tiedoston.</li>
		    
		    <li>Pyyntö polkuun <code>/video</code> palauttaa käyttäjälle Thymeleafin avulla kansiossa <code>src/main/resources/templates/</code> olevan <code>video.html</code>-tiedoston.</li>
		    
		  </ul>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun selaimella on tehty pyyntö sovelluksen juuripolkuun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex5.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>


	    <aside class="info">
	      <br/>
	      <h1>HTML</h1>

	      <p>Jos mietit mistä ihmeestä tuossa HTML-lyhenteessä on kyse tai haluat verestää HTML-muistiasi, nyt on hyvä hetki käydä lukemassa osoitteessa <a href="http://www.w3schools.com/html/default.asp" target="_blank">http://www.w3schools.com/html/default.asp</a> oleva HTML-opas.</p>

	    </aside>
	    
<!--	    
	    <p>Tarkastellaan edellä toteutettua sivun palauttamista vielä tarkemmin.</p>

<pre class="sh_java">
get("/", (req, res) -> {
    HashMap&lt;String, Object&gt; map = new HashMap&lt;&gt;();

    return new ModelAndView(map, "sivu");
}, new ThymeleafTemplateEngine());
</pre>

            <p>Ensimmäisellä rivillä kerromme, että juuripolkuun tulevat pyynnöt tulee käsitellä seuraavasti. Tätä seuraa pyynnön käsittelyyn liittyvä lohko, josta palautetaan olio, joka sisältää <code>HashMap</code>-olion sekä tiedon näytettävästä html-sivusta. Tämän jälkeen pyynnön käsittelyyn lisätään vielä erillinen olio, <code>ThymeleafTemplateEngine</code>, joka käsittelee html-sivun ennen sen palautusta.</p>
-->

            <h3>Datan lisääminen näkymään</h3>

	    <p>Palvelinohjelmistossa luodun tai haetun datan lisääminen näkymään tapahtuu <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/ui/Model.html" target="_blank">Model</a>-tyyppisen olion avulla. Kun lisäämme Model-olion pyyntöjä käsittelevän metodin parametriksi, lisää Spring-sovelluskehys sen automaattisesti käyttöömme. </p>


<pre class="sh_java">
package thymeleafdata;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

public class ThymeleafJaDataController {

    @RequestMapping("/")
    public String home(Model model) {
        return "index";
    }
}
</pre>
      
	    <p>Model on Spring-sovelluskehyksen käyttämä Map-rajapinnan toimintaa muistuttava lokerikko, missä jokaisella lokerolla on nimi, mihin arvon voi asettaa. Alla olevassa esimerkissä määrittelemme pyyntöjä käsittelevälle metodille Model-olion, jonka jälkeen lisäämme lokeroon nimeltä <code>teksti</code> arvon <code>"Hei mualima!"</code>.</p>


<pre class="sh_java">
package thymeleafdata;

import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class ThymeleafJaDataController {

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("teksti", "Hei mualima!");
        return "index";
    }
}
</pre>

	    <p>Kun käyttäjä tekee pyynnön, joka ohjautuu ylläolevaan metodiin, ohjautuu pyyntö <code>return</code>-komennon jälkeen Thymeleafille, joka saa käyttöönsä myös Model-olion ja siihen lisätyt arvot.</p>

	    <h3>Sivun käsittely Thymeleafissa</h3>
	    
	    <p>Oletetaan, että käytössämme olevan <code>index.html</code>-sivun lähdekoodi on seuraavanlainen:</p>
	    
<pre class="sh_xml">
&lt;!DOCTYPE html&gt;
&lt;html xmlns="http://www.w3.org/1999/xhtml" xmlns:th="http://www.thymeleaf.org"&gt;
    &lt;head&gt;
        &lt;title&gt;Otsikko&lt;/title&gt;
    &lt;/head&gt;

    &lt;body&gt;
        &lt;h1&gt;Hei maailma!&lt;/h1&gt;

        &lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;
    &lt;/body&gt;
&lt;/html&gt;
</pre>

	    <p>Kun Thymeleaf käsittelee HTML-sivun, se etsii sieltä elementtejä, joilla on <code>th:</code>-alkuisia attribuutteja. Ylläolevasta sivusta Thymeleaf löytää <code>h2</code>-elementin, jolla on attribuutti <code>th:text</code> -- <code>&lt;h2 th:text="${teksti}"&gt;testi&lt;/h2&gt;</code>. Attribuutti <code>th:text</code> kertoo Thymeleafille, että elementin tekstiarvo (testi) tulee korvata attribuutin arvon ilmaisemalla muuttujalla. Attribuutin <code>th:text</code> arvona on <code>${teksti}</code>, jolloin Thymeleaf etsii <code>model</code>-oliosta avaimella <code>"teksti"</code> arvoa.</p>
	    
	    <p>Käytännössä Thymeleaf etsii siis Model-oliosta lokeron nimeltä <code>teksti</code> ja asettaa siinä olevan arvon <code>h2</code>-elementin tekstiarvoksi. Tässä tapauksessa teksti <code>testi</code> korvataan Model-olion lokerosta teksti löytyvällä arvolla, eli tekstillä <code>Hei mualima!</code>.</p>
	    
	    <p></p>
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellomodel">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellomodel">
                      Hello Model
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellomodel" class="collapse">
		  
		  <p>Tehtäväpohjan mukana tulevaan HTML-tiedostoon on toteutettu tarina, joka tarvitsee otsikon ja päähenkilön. Toteuta pakkauksessa <code>wad.hellomodel</code> sijaitsevaan <code>HelloModelController</code>-luokkaan toiminnallisuus, joka käsittelee juuripolkuun tulevia pyyntöjä ja käyttää pyynnössä tulevia parametreja tarinan täydentämiseen. Voit olettaa, että pyynnön mukana tulevien parametrien nimet ovat <code>title</code> ja <code>person</code>.</p>
		  
		  <p>Lisää pyynnön mukana tulevien parametrien arvot Thymeleafille annettavaan HashMappiin. Otsikon avaimen tulee olla <code>"title"</code> ja henkilön avaimen tulee olla <code>"person"</code>. Palautettava sivu on <code>index.html</code>.</p>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun juuripolkuun tehdyssä pyynnössä on annettuna otsikoksi <code>Mökkielämää</code> ja henkilöksi <code>Leena</code>.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex6.png"/></p>
		  
		  <p>Palauta tehtävä TMC:lle kun olet valmis.</p>
		  
                </div>
              </div>
            </div>
	    
	    
	    <h2>Tiedon lähettäminen palvelimelle</h2>
	    
	    
            <p>HTML-sivuille voi määritellä lomakkeita (<a href="http://www.w3schools.com/html/html_forms.asp" target="_blank">form</a>), joiden avulla käyttäjä voi lähettää tietoa palvelimelle. Lomakkeen määrittely tapahtuu <code>form</code>-elementin avulla, jolle kerrotaan polku, mihin lomake lähetetään (action), sekä pyynnön tyyppi (method). Pidämme pyynnön tyypin toistaiseksi GET-tyyppisenä.</p>
	    
	    <p>Lomakkeeseen voidaan määritellä mm. tekstikenttiä (<code>&lt;input type="text"...</code>) sekä painike, jolla lomake lähetetään (<code>&lt;input type="submit"...</code>). Alla tekstikentän <code>name</code>-attribuutin arvoksi on asetettu <code>nimi</code>. Tämä tarkoittaa sitä, että kun lomakkeen tiedot lähetetään palvelimelle, tulee pyynnössä <code>nimi</code>-niminen parametri, jonka arvona on tekstikenttään kirjoitettu teksti.</p>

<pre class="sh_xml">
&lt;form th:action="@{/}" method="GET"&gt;
    &lt;input type="text" name="nimi"/&gt;
    &lt;input type="submit"/&gt;
&lt;/form&gt;</pre>

	    <aside class="info">
	      <br/>
	      <h1>Wut, th:action?</h1>

	      <p>Jos HTML-lomakkeet ovat sinulle tuttuja, saatoit huomata, että ylläolevassa lomakkeessa polku on määritelty attribuutin <code>th:action</code> avulla. Polku on lisäksi <code>@{<em>polku</em>}</code> <code>@</code>-merkin sekä aaltosulkujen sisällä -- <code>@{<em>polku</em>}</code>.</p>

	      <p>Tämän avulla varaudumme tilanteeseen, missä palvelimella voi olla useampia sovelluksia samaan aikaan. Tällöin ohjelmoimamme sovellus voi sijaita esimerkiksi polussa <code>http://osoite.com/sovellus1/</code> ja sovelluskehyksemme päättelee polun automaattisesti.</p>
	    </aside>

	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloform">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloform">
                      Hello Form
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloform" class="collapse">
		  
		  <p>Tehtäväpohjassa on toiminnallisuus, jonka avulla sivulla voi näyttää tietoa, ja jonka avulla sivulta lähetetty tieto voidaan myös käsitellä. Tiedon lähettämiseen tarvitaan sivulle kuitenkin lomake.</p>
		  
		  <p>Toteuta tehtäväpohjan kansiossa <code>src/main/resources/templates</code> olevaan <code>index.html</code>-tiedostoon lomake. Lomakkeessa tulee olla tekstikenttä, jonka nimen tulee olla <code>content</code>. Tämän lisäksi, lomakkeessa tulee olla myös nappi, jolla lomakkeen voi lähettää. Lomakkeen tiedot tulee lähettää juuriosoitteeseen GET-tyyppisellä pyynnöllä.</p>
		  
		  <p>Kun sovellus toimii oikein, voit vaihtaa sivulla näkyvää otsikkoa lomakkeen avulla.</p>
		  
                </div>
              </div>
            </div>

	    <aside class="info">
	      <br/>
	      <h1>Pyynnön parametrit</h1>

	      <p>Annotaatiolle <code>RequestParam</code> voi asettaa myös attribuutteja, joiden perusteella voidaan määritellä pyynnön parametrien pakollisuutta tai oletusarvoja. Katso edellisen tehtävän kontrolleriluokasta esimerkkiä.</p>
	    </aside>
	    

	    <h2>Listojen käsittely</h2>


	    <p>Thymeleafille annettavalle Model-oliolle voi asettaa tekstin lisäksi myös arvokokoelmia. Alla luomme "pääohjelmassa" listan, joka asetetaan Thymeleafin käsiteltäväksi menevään Model-olioon jokaisen juuripolkuun tehtävän pyynnön yhteydessä. Jos juuripolkuun lähetetään parametri nimeltä <code>"content"</code>, lisätään se myös listaan -- alla parametri on määritelty ei-pakolliseksi annotaation <code>@RequestMapping</code> attribuutilla <code>required = false</code>.</p>

<pre class="sh_java">
package thymeleafdata;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class ListaController {
    private List&lt;String&gt; lista;

    public ListaController() {
        this.lista = new ArrayList&lt;&gt;();
        this.lista.add("Hello world!");
    }

    @RequestMapping(value = "/")
    public String home(Model model, 
            @RequestParam(required = false) String content) {
        if(content != null && !content.trim().isEmpty()) {
            this.lista.add(content);
        }

        model.addAttribute("list", lista);
        return "index";
    }
}
</pre>

	    <p>Listan läpikäynti Thymeleafissa tapahtuu attribuutin <code>th:each</code> avulla. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on seuraavanlainen.</p>

<pre class="sh_xml">
&lt;pre&gt;
    &lt;p th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/p&gt;
&lt;/pre&gt;</pre>

            <p>Yllä käytämme attribuuttia nimeltä <code>lista</code> ja tulostamme yksitellen sen sisältämät alkiot. Attribuutin <code>th:each</code> voi asettaa käytännössä mille tahansa toistettavalle elementille. Esimerkiksi listan voisi tehdä seuraavalla tavalla.</p>

            <pre class="sh_xml">
&lt;ul&gt;
    &lt;li th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/li&gt;
&lt;/ul&gt;</pre>


            <p><em>Huom! Eräs klassinen virhe on määritellä iteroitava joukko merkkijonona <code>th:each="alkio : lista"</code>. Tämä ei luonnollisesti toimi.</em></p>

	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellolist">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellolist">
                      Hello List
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellolist" class="collapse">
		  
		  <p>Tehtäväpohjassa on palvelinpuolen toiminnallisuus, jossa käsitellään juuripolkuun tuleva pyyntö, sekä lisätään lista Thymeleafille sivun käsittelyyn. Tehtäväpohjaan liittyvä html-sivu ei kuitenkaan sisällä juurikaan toiminnallisuutta.</p>
		  
		  <p>Lisää html-sivulla (1) listalla olevien arvojen tulostaminen <code>th:each</code>-komennon avulla ja (2) lomake, jonka avulla palvelimelle voidaan lähettää uusia arvoja.</p>
		  
		  <p>Alla on esimerkki ohjelman toiminnasta, kun sivulle on lisätty muutama rivi lomakkeen avulla. Viimeisimpänä on juuri lisätty teksti "Hello?".</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex8.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    

	    <div class="tehtavat">
	      <div class="tehtava" id="t-notebook">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-notebook">
                      Notebook
                    </a>
                  </h1>
                </header>
		
                <div id="t-notebook" class="collapse">
		  
		  <p>Toteuta tehtäväpohjan pakkauksessa <code>wad.notebook</code> olevaan <code>NotebookController</code>-luokkaan muistio-ohjelma, jolle voi lisätä muistiinpanoja. Tee ohjelmastasi sellainen, että jos muistiinpanoja on yli 10, se muistaa ja näyttää niistä vain viimeisimmät 10.</p>
		  
		  <p>Alla on esimerkki muistiosta, kun siihen on lisätty 3 viestiä.</p>
		  
		  <p><img class="browser-img" src="img/mooc/ex9.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    
	    
	    
	    <h2>Pyynnön uudelleenohjaus ja POST</h2>
	    
	    <p>Olemme tähän mennessä toteuttaneet palvelinohjelmistoihimme vain kyvyn käsitellä GET-tyyppisiä pyyntöjä. GET-tyyppisiä pyyntöjä käytetään ensisijaisesti tiedon hakemiseen, eikä niitä oikeastaan pitäisi käyttää laisinkaan tiedon muuttamiseen. Toinen tapa lähettää tietoa palvelimelle on <code>POST</code>-tyyppiset pyynnöt, joita käytettäessä pyynnön parametrit kulkevat pyynnön <em>rungossa</em> -- palaamme pyynnön erilaisiin muotoihin myöhemmin kurssilla.</p>
	    
            <p>Oikeastaan kaikki pyynnöt, joissa lähetetään tietoa palvelimelle, ovat ongelmallisia jos pyynnön vastauksena palautetaan näytettävä sivu. Tällöin käyttäjä voi sivun uudelleenlatauksen (esim. painamalla F5) yhteydessä lähettää aiemmin lähettämänsä datan vahingossa uudelleen. Kokeile tätä jossain aiemmassa tehtävässä kun olet lähettänyt lomakkeella tietoa!</p>
	    
            <p>On tyylikkäämpää toteuttaa lomakkeen dataa vastaanottava toiminnallisuus siten, että lähetetyn tiedon käsittelyn jälkeen käyttäjälle palautetaan vastauksena uudelleenohjauspyyntö. Tämän jälkeen käyttäjän selain tekee uuden pyynnön uudelleenohjauspyynnön mukana annettuun osoitteeseen. Tätä toteutustapaa kutsutaan <a href="http://en.wikipedia.org/wiki/Post/Redirect/Get" target="_blank">Post/Redirect/Get</a>-suunnittelumalliksi ja sillä mm. estetään lomakkeiden uudelleenlähetys, jonka lisäksi vähennetään toiminnallisuuden toisteisuutta.</p>

	    <h3>POST-pyynnön kuuntelu ja uudelleenohjaus</h3>
	    
	    <p>Alla on toteutettu POST-tyyppistä pyyntöä kuunteleva polku sekä siihen liittyvä toiminnallisuus. Pyynnön tyyppi määritellään annotaation @RequestMapping attribuutiksi (method-attribuutti). Tällöin kuunneltava polku tulee määritellä myös tarkemmin (value-attribuutti). Palauttamalla pyyntöä käsittelevästä metodista merkkijono <code>redirect:/</code> kerrotaan, että pyynnölle tulee lähettää vastauksena uudelleenohjauspyyntö polkuun <code>"/"</code>. Kun selain vastaanottaa uudelleenohjauspyynnön, tekee se GET-tyyppisen pyynnön uudelleenohjauspyynnössä annettuun osoitteeseen.</p>

<pre class="sh_java">
package uudelleenohjaus;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RequestParam;

@Controller
public class ListaController {
    private List&lt;String&gt; lista;

    public ListaController() {
        this.lista = new ArrayList&lt;&gt;();
        this.lista.add("Hello world!");
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", lista);
        return "index";
    }

    @RequestMapping(value = "/", method = RequestMethod.POST)
    public String post(@RequestParam String content) {
        if(!content.trim().isEmpty()) {
            this.lista.add(content);
        }

        return "redirect:/";
    }
}
</pre>
	    <p></p>
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellopostredirectget">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopostredirectget">
                      Hello POST/Redirect/GET
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellopostredirectget" class="collapse">
		  
		  <p>Tehtäväpohjassa on sekä muistilappujen listaamistoiminnallisuus, että lomake, jonka avulla voidaan lähettää POST-tyyppisiä pyyntöjä palvelimelle. Toteuta sovellukseen toiminnallisuus, missä palvelin kuuntelee POST-tyyppisiä pyyntöjä, lisää pyynnön yhteydessä tulevan tiedon sovelluksessa olevaan listaan ja uudelleenohjaa käyttäjän tekemään GET-tyyppisen pyynnön juuriosoitteeseen.</p>
		  
                </div>
              </div>
            </div>
	    

	    <h2>Olioita kaikkialla!</h2>
	    
	    <p>Thymeleafille annettavaan Modeliin voi hyvin lisätä myös olioita. Oletetaan, että käytössämme on henkilöä kuvaava luokka.</p>
	    
<pre class="sh_java">
public class Henkilo {
    private String nimi;

    public Henkilo(String nimi) {
        this.nimi = nimi;
    }

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}
</pre>

	    <p>Henkilö-olion lisääminen on suoraviivaista:</p>

<pre class="sh_java">
    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("henkilo", new Henkilo("Le Pigeon"));
        return "index";
    }
</pre>

	    <p>Kun sivua luodaan, henkilöön päästään käsiksi modeliin asetetun avaimen perusteella. Edellä luotu "Le Pigeon"-henkilö on tallessa avaimella "henkilo". Kuten aiemminkin, avaimella pääsee olioon käsiksi.</p>
	    
	    
<pre class="sh_xml">
&lt;h2 th:text="${henkilo}"&gt;Henkilön nimi&lt;/h2&gt;</pre>

	    <p>Ylläolevaa Henkilön tulostusta kokeillessamme saamme näkyville (esim.) merkkijonon <code>Henkilo@29453f44</code> -- ei ihan mitä toivoimme. Käytännössä Thymeleaf kutsuu edellisessä tapauksessa olioon liittyvää <code>toString</code>-metodia, jota emme ole määritelleet. Pääsemme oliomuuttujiin käsiksi olemassaolevien <code>get<em>Muuttuja</em></code>-metodien kautta. Jos haluamme tulostaa Henkilö-olioon liittyvän nimen, kutsumme metodia <code>getNimi</code>. Thymeleafin käyttämässä notaatiossa kutsu muuntuu muotoon <code>henkilo.nimi</code>. Saamme siis halutun tulostuksen seuraavalla tavalla:</p>

<pre class="sh_xml">
&lt;h2 th:text="${henkilo.nimi}"&gt;Henkilön nimi&lt;/h2&gt;</pre>

	    <p></p>

	    <h3>Olioita listalla</h3>
	    
	    <p>Listan läpikäynti Thymeleafissa tapahtuu attribuutin <code>th:each</code> avulla. Sen määrittely saa muuttujan nimen, johon kokoelmasta otettava alkio kullakin iteraatiolla tallennetaan, sekä läpikäytävän kokoelman. Perussyntaksiltaan <code>th:each</code> on jo tullut aiemmin tutuksi.</p>
	    
<pre class="sh_xml">
&lt;pre&gt;
    &lt;p th:each="alkio : ${lista}"&gt;
        &lt;span th:text="${alkio}"&gt;hello world!&lt;/span&gt;
    &lt;/p&gt;
&lt;/pre&gt;</pre>

            <p>Iteroitavan joukon alkioiden ominaisuuksiin pääsee käsiksi aivan samalla tavalla kuin muiden olioiden ominaisuuksiin. Tutkitaan seuraavaa esimerkkiä, jossa listaan lisätään kaksi henkilöä, lista lisätään pyyntöön ja lopulta luodaan näkymä Thymeleafin avulla.</p>

<pre class="sh_java">
package henkilot;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HenkiloController {
    private List&lt;Henkilo&gt; henkilot;

    public ListaController() {
        this.henkilot = new ArrayList&lt;&gt;();
        this.henkilot.add(new Person("James Gosling"));
        this.henkilot.add(new Person("Martin Odersky"));
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", henkilot);
        return "index";
    }
}
</pre>

                <pre class="sh_xml">
&lt;p&gt;Ja huomenna puheet pitävät:&lt;/p&gt;
&lt;ol&gt;
    &lt;li th:each="henkilo : ${list}"&gt;
        &lt;span th:text="${henkilo.nimi}"&gt;Esimerkkihenkilo&lt;/span&gt;
    &lt;/li&gt;
&lt;/ol&gt;
</pre>

            <p>Käyttäjälle lähetettävä sivu näyttää palvelimella tapahtuneen prosessoinnin jälkeen seuraavalta.</p>

<pre class="sh_xml">
&lt;p&gt;Ja huomenna puheet pitävät:&lt;/p&gt;
&lt;ol&gt;
    &lt;li&gt;&lt;span&gt;James Gosling&lt;/span&gt;&lt;/li&gt;
    &lt;li&gt;&lt;span&gt;Martin Odersky&lt;/span&gt;&lt;/li&gt;
&lt;/ol&gt;</pre>

	    <p></p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloobjects">

		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloobjects">
                      Hello Objects
                    </a>
                      </h1>
                </header>

                <div id="t-helloobjects" class="collapse">

		  <p>Tehtäväpohjassa on sovellus, jossa käsitellään <code>Item</code>-tyyppisiä olioita. Tehtävänäsi on lisätä sovellukseen lisätoiminnallisuutta:</p>
		  
		  <ul>
		    <li>Kun käyttäjä avaa selaimella sovelluksen juuripolun, tulee hänen lomakkeen lisäksi nähdä lista esineistä. Jokaisesta esineestä tulee tulla ilmi sen nimi (name) ja tyyppi (type).</li>
		    <li>Kun käyttäjä lähettää lomakkeella uuden esineen palvelimelle, tulee palvelimen säilöä esine listalle seuraavaa näyttämistä varten. Huomaa, että lomake lähettää tiedot POST-pyynnöllä sovelluksen juureen. Kun esine on säilötty, uudelleenohjaa käyttäjän pyyntö siten, että käyttäjän selain tekee GET-tyyppisen pyynnön sovelluksen juuripolkuun.</li>
		  </ul>
		  
		  <p>Allaolevassa esimerkissä sovellukseen on lisätty olemassaolevan taikurin hatun lisäksi <a href="https://en.wikipedia.org/wiki/Party_hat" target="_blank">Party hat</a>, eli bilehattu.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex11.png"/></p>

                </div>
              </div>
            </div>


	    <h2>Polkumuuttujat</h2>

	    <p>Polkuja käytetään erilaisten resurssien tunnistamiseen ja yksilöintiin. Usein kuitenkin vastaan tulee tilanne, missä luodut resurssit ovat uniikkeja, emmekä niiden tietoja ennen sovelluksen käynnistymistä. Jos haluaisimme näyttää tietyn resurssin tiedot, voisimme lisätä pyyntöön parametrin -- esim <code>esineet?tunnus=3</code>, minkä arvo olisi haetun resurssin tunnus.</p>

	    <p>Toinen vaihtoehto on ajatella polkua haettavan resurssin tunnistajana. Annotaatiolle <code>@RequestMapping</code> määriteltävään polkuun voidaan määritellä polkumuuttuja aaltosulkujen avulla. Esimerkiksi polku <code>"/{arvo}"</code> ottaisi vastaan minkä tahansa juuripolun alle tulevan kyselyn ja tallentaisi arvon myöhempää käyttöä varten. Tällöin jos käyttäjä tekee pyynnön esimerkiksi osoitteeseen <code>http://localhost:8080/kirja</code>, tallentuu arvo "kirja" myöhempää käyttöä varten. Polkumuuttujiin pääsee käsiksi pyyntöä käsittelevälle metodille määriteltävän annotaation <a href="http://docs.spring.io/spring/docs/current/javadoc-api/org/springframework/web/bind/annotation/PathVariable.html" target="_blank">@PathVariable</a> avulla.</p>

	    <p>Yksittäisen henkilön näyttäminen onnistuisi esimerkiksi seuravavasti:</p>

<pre class="sh_java">
package henkilot;

import java.util.List;
import java.util.ArrayList;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.RequestMapping;

@Controller
public class HenkiloController {
    private List&lt;Henkilo&gt; henkilot;

    public ListaController() {
        this.henkilot = new ArrayList&lt;&gt;();
        this.henkilot.add(new Person("James Gosling"));
        this.henkilot.add(new Person("Martin Odersky"));
    }

    @RequestMapping("/")
    public String home(Model model) {
        model.addAttribute("list", henkilot);
        return "index";
    }

    @RequestMapping("/{id}")
    public String getOne(Model model, @PathVariable Integer id) {
        if(id &lt; 0 || id &gt;= this.henkilot.size()) {
            return home(model);
        }

        model.addAttribute("henkilo", henkilot.get(id));
        return "henkilo";
    }
}
</pre>

	    <p></p>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellopathvariables">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellopathvariables">
                      Hello Path Variables
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellopathvariables" class="collapse">

		  <p>Tehtäväpohjassa on sovellus, jossa käsitellään taas edellisestä tehtävästä tuttuja <code>Item</code>-tyyppisiä olioita. Tällä kertaa esineet kuitenkin kuvastavat hattuja. Kun sovelluksen juureen tehdään pyyntö, käyttäjälle näytetään oletushattu ("default"). Lisää sovellukseen toiminnallisuus, minkä avulla tiettyyn polkuun tehtävä kysely palauttaa sivun, jossa näkyy tietyn hatun tiedot -- huomaa, että voit asettaa polkumuuttujan tyypiksi myös Stringin.</p>
		  
		  <p>Sovelluksen juuripolkuun tehtävä pyyntö näyttää seuraavanlaisen sivun:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex12-default.png"/></p>

		  <p>Muihin osoitteisiin tehtävät pyynnöt taas palauttavat tehtäväpohjassa olevasta <code>items</code>-hajautustaulusta polkuun sopivan hatun. Esimerkiksi pyyntö polkuun <code>/ascot</code> näyttää seuraavanlaisen sivun:</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex12-ascot.png"/></p>

                </div>
              </div>
            </div>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-helloindividualpages">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-helloindividualpages">
                      Hello Individual Pages
                    </a>
                  </h1>
                </header>
		
                <div id="t-helloindividualpages" class="collapse">
		  
		  <p>Edellisessä tehtävässä käytössämme oli vain yksi sivu. Olisi kuitenkin hienoa, jos jokaiselle hatulle olisi oma sivu -- ainakin sovelluksen käyttäjän näkökulmasta.</p>
		  
		  <p>Tehtäväpohjassa on valmiina sovellus, joka listaa olemassaolevat hatut ja näyttää ne käyttäjälle. Jokaisen hatun yhteydessä on linkki, jota klikkaamalla pitäisi päästä hatun omalle sivulle.</p>
		  
		  <p>Toteuta sekä html-sivu (<code>single.html</code>), että sopiva metodi, joka ohjaa pyynnön sivulle.</p>
		  

		  <p>Pyyntö sovelluksen juureen luo seuraavanlaisen sivun.</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex13-list.png"/></p>
		  
		  <p>Jos sivulta klikkaa hattua, pääsee tietyn hatun tiedot sisältävälle sivulle. Alla olevassa esimerkissä on klikattu taikurin hattuun liittyvää linkkiä.</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex13-single.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-todoapplication">

		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-todoapplication">
                      Todo Application
                    </a>
                  </h1>
                </header>
		
                <div id="t-todoapplication" class="collapse">
		  
		  <p>Tässä tehtävässä tulee rakentaa tehtävien hallintaan tarkoitettu sovellus. Sovelluksen käyttämät sivut ovat valmiina näkyvissä, itse sovelluksen pääset toteuttamaan itse.</p>
		  
		  <p>Sovelluksen tulee sisältää seuraavat toiminnallisuudet:</p>
		  
		  <ul>
		    <li>Kaikkien tehtävien listaaminen. Kun käyttäjä tekee pyynnön sovelluksen juuripolkuun, tulee hänelle näyttää sivu, missä tehtävät on listattuna. Sivulla on myös lomake tehtävien lisäämiseen. </li>
		    <li>Yksittäisen tehtävän lisääminen. Kun käyttäjä täyttää lomakkeen sivulla ja lähettää tiedot palvelimelle, tulee sovelluksen lisätä tehtävä näytettävään listaan.</li>
		    <li>Yksittäisen tehtävän poistaminen. Kun käyttäjä painaa tehtävään liittyvää <code>Done!</code>-nappia, tulee tehtävä poistaa listalta. Toteuta tämä niin, että metodin tyyppi on <code>DELETE</code>:
<pre class="sh_java">
@RequestMapping(value = "/{item}", method = RequestMethod.DELETE)</pre></li>
		    <li>Yksittäisen tehtävän näyttäminen. Kun käyttäjä klikkaa tehtävään liittyvää linkkiä, tulee käyttäjälle näyttää tehtäväsivu. Huom! Tehtävään liittyvien tarkistusten määrä tulee kasvaa aina yhdellä kun sivulla vieraillaan.</li>
		  </ul>
		  
		  <p>Alla kuva tehtävien listauksesta:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-list.png"/></p>
		  
		  <p>Kun tehtävää klikkaa, näytetään erillinen tehtäväsivu:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-item-1.png"/></p>
		  
		  <p>Kun sivu avataan toisen kerran, kasvaa tehtävien tarkistukseen liittyvä laskuri:</p>
		  
		  <p><img class="browser-img" src="img/2016-mooc/ex14-item-2.png"/></p>
		  
		  
                </div>
              </div>
            </div>
	    

	    <h2>Tiedon tallentaminen</h2>

	    <p>Sovelluksemme -- vaikka huikeita ovatkin -- ovat melko alkeellisia, sillä sovelluksissa käsiteltävää tietoa ei tallenneta mihinkään. Esimerkiksi lomakkeen avulla sovellukselle lähetettävä data katoaa kun sovellus käynnistetään uudestaan. Tämä ei ole kivaa.</p>

	    <p>Tietokannat ovat palvelinohjelmistosta erillisiä sovelluksia, joiden ensisijainen tehtävä on varmistaa, että käytettävä tieto ei katoa. Otetaan ensiaskeleet tietokannan käyttöön web-palvelinohjelmistoissa -- tutustumme tietokantoihin tarkemmin myöhemmin kurssilla. Käytämme tietokantatoiminnallisuuden toteuttamisessa <a href="http://projects.spring.io/spring-data-jpa/" target="_blank">Spring Data JPA</a>-komponenttia, johon löytyy myös aloituspaketti käyttämästämme Spring Bootista.</p>

	    <aside class="info">

	      <br/>

	      <h1>Spring Data JPA:n käyttöönotto</h1>
		  
	      <p>Saadaksemme Spring Data JPA:n käyttöömme, tulee meidän lisätä se <code>pom.xml</code>-tiedostoon. Spring Bootin kautta löytyy näppärä paketti <code>spring-boot-starter-data-jpa</code>, joka vähentää yksittäisten riippuvuuksien lisäämistä. Tämän lisäksi tarvitsemme testikäyttöön sopivan tietokannan -- valitaan <a href="http://www.h2database.com/" target="_blank">H2 Database</a>, jonka voi ladata muistiin sovelluksen käynnistyessä.</p>

	      <p>Lisätään projektiin seuraavat riippuvuudet:</p>

	      <pre class="sh_xml">
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
&lt;/dependency&gt;
&lt;dependency&gt;
    &lt;groupId&gt;com.h2database&lt;/groupId&gt;
    &lt;artifactId&gt;h2&lt;/artifactId&gt;
&lt;/dependency&gt;</pre>

	      <p>Kun projektin riippuvuudet noudetaan Mavenin avulla, on tietokanta valmis testikäyttöön.</p>

	    </aside>


	    <h3>Tietokantaan tallennettavat oliot eli entiteetit</h3>

            <p>Käytämme ORM-kirjastoa (object relational mapping), jonka tehtävänä on muuntaa oliot tietokantaan tallennettavaan muotoon. Karkeasti ajatellen luokka vastaa tietokantataulua ja oliomuuttujat vastaavat tietokannan sarakkeita. Jokainen taulun rivi vastaa yhtä luokasta tehtyä oliota.</p>

	    <p>Luokat, joista tehdyt oliot voidaan tallentaa tietokantaan, tulee annotoida <code>@Entity</code>-annotaatiolla. Tämän lisäksi luokille tulee määritellä tunnuskenttä, jonka avulla niihin liittyvät oliot voidaan yksilöidä. Voimme käyttää tunnuskentän luomiseen valmista <code>AbstractPersistable</code>-yliluokkaa, jota perittäessä kerromme uniikin tunnuksen tyypin. Esimerkiksi <code>Henkilo</code>-luokasta voidaan tehdä tietokantaan tallennettava seuraavilla muutoksilla.</p>

                <pre class="sh_java">
package wad.domain;

import javax.persistence.Entity;
import org.springframework.data.jpa.domain.AbstractPersistable;

@Entity
public class Henkilo extends AbstractPersistable&lt;Long&gt; {

    private String nimi;

    public String getNimi() {
        return this.nimi;
    }

    public void setNimi(String nimi) {
        this.nimi = nimi;
    }
}</pre>

            <p>Kun käytössämme on tietokantaan tallennettava luokka, voimme luoda tietokannan käsittelyyn käytettävän <em>rajapinnan</em>. Kutsutaan tätä rajapintaoliota nimellä <code>HenkiloRepository</code>.</p>

                <pre class="sh_java">
// pakkaus

import wad.domain.Person;
import org.springframework.data.jpa.repository.JpaRepository;

public interface HenkiloRepository extends JpaRepository&lt;Henkilo, Long&gt; {

}</pre>

            <p>Rajapinta perii Spring Data-projektin <code>JpaRepository</code>-rajapinnan; samalla kerromme, että tallennettava olio on tyyppiä <code>Person</code> ja että tallennettavan olion tunnus on <code>Long</code>-tyyppiä. Tämä tyyppi on sama kuin aiemmin <code>AbstractPersistable</code>-luokan perinnässä parametriksi asetettu tyyppi. Spring osaa käynnistyessään etsiä mm. JpaRepository-rajapintaluokan periviä luokkia. Jos niitä löytyy, se luo niiden pohjalta tietokannan käsittelyyn sopivan olion sekä asettaa olion ohjelmoijan haluamiin muuttujiin.</p>

	    <p>Nämä muuttujat tulee määritellä <code>@Autowired</code>-annotaatiolla -- jokaiselle muuttujalle tulee oma annotaatio -- palaamme myöhemmin kurssilla tarkemmin tähän ns. olioiden automaattiseen asettamiseen.</p>

            <p>Kun olemme luoneet rajapinnan <code>HenkiloRepository</code>, voimme lisätä sen käyttöömme esimerkiksi kontrolleriluokkaan. Tämä tapahtuu seuraavasti.</p>

                <pre class="sh_java">
// ...

@Controller
public class HenkiloController {

    @Autowired
    private HenkiloRepository henkiloRepository;

    // ...
}</pre>

            <p>Nyt tietokantaan pääsee käsiksi <code>HenkiloRepository</code>-olion kautta. Osoitteessa <a href="http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html" target="_blank">http://docs.spring.io/spring-data/jpa/docs/current/api/org/springframework/data/jpa/repository/JpaRepository.html</a> on JpaRepository-rajapinnan API-kuvaus, mistä löytyy rajapinnan tarjoamien metodien kuvauksia. Voimme esimerkiksi toteuttaa tietokannassa olevien olioiden listauksen sekä yksittäisen olion haun seuraavasti:</p>

            <pre class="sh_java">
// ...

@Controller
public class HenkiloController {

    @Autowired
    private HenkiloRepository henkiloRepository;

    @RequestMapping(method = RequestMethod.GET)
    public String list(Model model) {
        model.addAttribute("list", henkiloRepository.findAll());
        return "henkilot"; // erillinen henkilot.html
    }

    @RequestMapping(value = "/{id}", method = RequestMethod.GET)
    public String get(Model model, @PathVariable Long id) {
        model.addAttribute("henkilo", henkiloRepository.findOne(id));
        return "henkilo"; // erillinen henkilo.html
    }
}</pre>

	    <div class="tehtavat">
	      <div class="tehtava" id="t-hellodatabase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-hellodatabase">
                      Hello Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-hellodatabase" class="collapse">
		  
		  <p>Tässä tehtävässä on valmiiksi toteutettuna tietokantatoiminnallisuus sekä esineiden noutaminen tietokannasta. Lisää sovellukseen toiminnallisuus, jonka avulla esineiden tallentaminen tietokantaan onnistuu valmiiksi määritellyllä lomakkeella.</p>
		  
		  <p>Alla esimerkki sovelluksesta kun tietokantaan on lisätty muutama rivi:</p>

		  <p><img class="browser-img" src="img/2016-mooc/ex15.png"/></p>
		  
                </div>
              </div>
            </div>		
	    
	    <div class="tehtavat">
	      <div class="tehtava" id="t-tododatabase">
		
		<header>
		  <h1>
                    <a data-toggle="collapse" class="collapsed" href="#t-tododatabase">
                      Todo Database
                    </a>
                  </h1>
                </header>
		
                <div id="t-tododatabase" class="collapse">
		  
		  <p>Luo tässä TodoApplication-tehtävässä nähty tehtävien hallintaan tarkoitettu toiminnallisuus mutta siten, että tehtävät tallennetaan tietokantaan. Tässä tehtävässä entiteettiluokan nimen tulee olla <code>Item</code> ja avaimen tyypin tulee olla <code>Long</code>: <pre class="sh_java">
@Entity
public class Item extends AbstractPersistable&lt;Long&gt; {
...</pre></p>
		  <p>Noudata lisäksi HTML-sivujen rakennetta ja toiminnallisuutta.</p>
		  
                </div>
              </div>
            </div>
	    

	  </section>
	  
<!-- BEGIN FOOTER -->

        <footer>
            <p>
                <a id="license" rel="license" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img alt="Creative Commons License" style="border-width:0; float:left; padding:15px" src="https://i.creativecommons.org/l/by-nc-sa/4.0/88x31.png" /></a>
                <small>T&auml;m&auml; materiaali on lisensoitu Creative Commons BY-NC-SA-lisenssill&auml;, joten voit k&auml;ytt&auml;&auml; ja levitt&auml;&auml; sit&auml; vapaasti, kunhan alkuper&auml;isten tekij&ouml;iden nimi&auml; ei poisteta. Jos teet muutoksia materiaaliin ja haluat levitt&auml;&auml; muunneltua versiota, se t&auml;ytyy lisensoida samalla lisenssill&auml;. Materiaalien k&auml;ytt&ouml; kaupalliseen tarkoitukseen on ilman erillist&auml; lupaa kielletty. Tekij&auml;(t): <a href="http://www.cs.helsinki.fi/en/people/avihavai" target="_blank">Arto Hellas</a> sekä <a href="http://www.cs.helsinki.fi/en/rage" target="_blank">Agile Education Research</a> -tutkimusryhm&auml;.
            </p>
        </footer>

        <div class="hidden">
            <p>the end.</p>
        </div>


        <script src="js/libs/jquery/jquery.js"></script>
        <script src="js/libs/jqueryui/jquery-ui.js"></script>
	<script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.6/js/bootstrap.min.js"></script>
        <script src="js/libs/syntaxhighlight/sh_main.min.js"></script>

        <script src="js/libs/chartist.min.js"></script>
        <script src="js/libs/visibility.core.js"></script>
        <script src="js/libs/visibility.timers.js"></script>
        <script src="js/libs/visibility.fallback.js"></script>
        <script src="js/js-logger.js"></script>
        <script src="js/verticalfloat.js"></script>
        <script src="js/pheromones.js"></script>
        <script src="js/wepa.js"></script>


    </body>
</html>
